import java.nio.charset.Charset
import java.nio.charset.StandardCharsets
import java.util.function.Function

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This adds javacc generation support.

configure(rootProject) {
  configurations {
    javacc
  }

  dependencies {
    javacc "net.java.dev.javacc:javacc:${scriptDepVersions['javacc']}"
  }

  task javacc() {
    description "Regenerate sources for corresponding javacc grammar files."
    group "generation"

    dependsOn ":lucene:queryparser:javaccParserClassic"
    dependsOn ":lucene:queryparser:javaccParserSurround"
    dependsOn ":lucene:queryparser:javaccParserFlexible"
    dependsOn ":solr:core:javaccSolrParser"
  }
}

// We always regenerate, no need to declare outputs.
class JavaCCTask extends DefaultTask {
  @Input
  File javaccFile

  JavaCCTask() {
    dependsOn(project.rootProject.configurations.javacc)
  }

  /**
   * Utility function to read a file, apply changes to its content and write it back.
   */
  public static String modifyFile(File path, Function<String, String> modify) {
    Function<String, String> normalizeEols = { text -> text.replaceAll("\r\n", "\n") }
    modify = normalizeEols.andThen(modify).andThen(normalizeEols)

    String original = path.getText("UTF-8")
    String modified = modify.apply(original)
    if (!original.equals(modified)) {
      path.write(modified, "UTF-8")
    }
  }

  @TaskAction
  def generate() {
    if (!javaccFile || !javaccFile.exists()) {
      throw new RuntimeException("JavaCC input file does not exist: ${javaccFile}")
    }

    // Remove previous files so we can regenerate them. javacc doesn't want to overwrite
    // locally modified files.
    def parentDir = javaccFile.parentFile
    def toDelete = project.fileTree(parentDir, {
      include "**/*.java"
    }).findAll { file -> file.getText("UTF-8").contains("Generated By:JavaCC") }
    project.delete(toDelete)

    logger.lifecycle("Regenerating JavaCC:\n  from: ${javaccFile}\n    to: ${parentDir}")

    def output = new ByteArrayOutputStream()
    def result = project.javaexec {
      classpath {
        project.rootProject.configurations.javacc
      }

      ignoreExitValue = true
      standardOutput = output
      errorOutput = output

      main = "org.javacc.parser.Main"
      args += [
          "-OUTPUT_DIRECTORY=${parentDir}",
          javaccFile
      ]
    }

    // Unless we request verbose logging, don't emit javacc output.
    if (result.exitValue != 0) {
      throw new GradleException("JavaCC failed to compile ${javaccFile}, here is the compilation output:\n${output}")
    }

    // Make sure we don't have warnings.
    if (output.toString(Charset.defaultCharset()).contains("Warning:")) {
      throw new GradleException("JavaCC emitted warnings for ${javaccFile}, here is the compilation output:\n${output}")
    }

    //
    // Apply common cleanups.
    //

    // This is a minor typo in a comment that nonetheless people have hand-corrected in the past.
    modifyFile(project.file("${parentDir}/CharStream.java"), { text ->
      return text.replace(
          "implemetation",
          "implementation");
    })

    def generatedFiles = project.fileTree(parentDir, {
      include "*.java"
      include { FileTreeElement element ->
        element.file.getText("UTF-8").contains("Generated By:JavaCC:")
      }
    })

    generatedFiles.each {file ->
      modifyFile(file, { text ->
        text = text.replace("StringBuffer", "StringBuilder")
        return text
      })
    }

    project.fileTree(parentDir, {
      include "*TokenManager.java"
    }).each { file ->
      modifyFile(file, { text ->
        // Eliminates redundant cast message.
        text = text.replace(
            "int hiByte = (int)(curChar >> 8);",
            "int hiByte = curChar >> 8;")
        // Access to forbidden APIs.
        text = text.replace(
            "public  java.io.PrintStream debugStream = System.out;",
            "// (debugStream omitted).")
        text = text.replace(
            "public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }",
            "// (setDebugStream omitted).")
        return text
      })
    }
  }
}

configure(project(":lucene:queryparser")) {
  task javaccParserClassic(type: JavaCCTask) {
    description "Regenerate classic query parser from lucene/queryparser/classic/QueryParser.jj"
    group "generation"

    javaccFile = file('src/java/org/apache/lucene/queryparser/classic/QueryParser.jj')
    def parentDir = javaccFile.parentFile // I'll need this later.

    doLast {
      // control visibility issues
      ant.replace(file: file("${parentDir}/QueryParser.java"),
          token: "public QueryParser(CharStream ",
          value: "protected QueryParser(CharStream ",
          encoding: 'UTF-8')
      ant.replace(file: file("${parentDir}/QueryParser.java"),
          token: "public QueryParser(QueryParserTokenManager ",
          value: "protected QueryParser(QueryParserTokenManager ",
          encoding: 'UTF-8')

      // Some redundant casts etc. in queryparser.java
      ant.replace(file: file("${parentDir}/QueryParser.java"),
          token: "new java.util.ArrayList<int[]>",
          value: "new java.util.ArrayList<>",
          encoding: 'UTF-8')
      ant.replace(file: file("${parentDir}/QueryParser.java"),
          token: "new java.util.ArrayList<int[]>",
          value: "new java.util.ArrayList<>",
          encoding: 'UTF-8')
      ant.replace(file: file("${parentDir}/QueryParser.java"),
          token: "(int)(curChar >> 8);",
          value: "curChar >> 8;",
          encoding: 'UTF-8')
      // Remove unnecessary imports
      def separator = System.getProperty('line.separator')
      [/import java\.io\.StringReader;/,
       /import java\.util\.ArrayList;/,
       /import java\.util\.Arrays;/,
       /import java\.util\.HashSet;/,
       /import java\.util\.List;/,
       /import java\.util\.Locale;/,
       /import java\.util\.Set;/,
       /import org\.apache\.lucene\.analysis\.Analyzer;/,
       /import org\.apache\.lucene\.document\.DateTools;/,
       /import org\.apache\.lucene\.search\.BooleanClause;/,
       /import org\.apache\.lucene\.search\.Query;/,
       /import org\.apache\.lucene\.search\.TermRangeQuery/,
       /import org\.apache\.lucene\.search\.TermRangeQuery;/
      ].each {
        ant.replaceregexp(file: file("${parentDir}/QueryParserTokenManager.java"),
            match: "${it}\\s*${separator}",
            replace: "",
            encoding: "UTF-8")
      }
    }
  }
}

configure(project(":lucene:queryparser")) {
  task javaccParserSurround(type: JavaCCTask) {
    description "Regenerate surround query parser from lucene/queryparser/surround/parser/QueryParser.jj"
    group "generation"

    javaccFile = file('src/java/org/apache/lucene/queryparser/surround/parser/QueryParser.jj')
    def parentDir = javaccFile.parentFile

    doLast {
      def separator = System.getProperty('line.separator')

      // Remove unneeded import
      ant.replaceregexp(match: /import org\.apache\.lucene\.analysis\.TokenStream;\s*${separator}${separator}/,
          replace: "",
          encoding: "UTF-8") {
        ant.fileset(dir: parentDir, includes: "QueryParser.java")
      }

      // Eliminate compiler warning
      ant.replace(file: file("${parentDir}/QueryParser.java"),
          token: "new java.util.ArrayList<int[]>",
          value: "new java.util.ArrayList<>",
          encoding: 'UTF-8')

      // There are a bunch of unused imports we need to remove to pass precommit
      [
          /import java\.util\.ArrayList;/,
          /import java\.util\.List;/,
          /import java\.io\.StringReader;/,
          /import org\.apache\.lucene\.analysis\.TokenStream;/,
          /import org\.apache\.lucene\.queryparser\.surround\.query\.SrndQuery;/,
          /import org\.apache\.lucene\.queryparser\.surround\.query\.FieldsQuery;/,
          /import org\.apache\.lucene\.queryparser\.surround\.query\.OrQuery;/,
          /import org\.apache\.lucene\.queryparser\.surround\.query\.AndQuery;/,
          /import org\.apache\.lucene\.queryparser\.surround\.query\.NotQuery;/,
          /import org\.apache\.lucene\.queryparser\.surround\.query\.DistanceQuery;/,
          /import org\.apache\.lucene\.queryparser\.surround\.query\.SrndTermQuery;/,
          /import org\.apache\.lucene\.queryparser\.surround\.query\.SrndPrefixQuery;/,
          /import org\.apache\.lucene\.queryparser\.surround\.query\.SrndTruncQuery;/
      ].each {
        ant.replaceregexp(file: file("${parentDir}/QueryParserTokenManager.java"),
            match: "${it}\\s*${separator}",
            replace: "",
            encoding: "UTF-8")
      }
    }
  }
}

configure(project(":lucene:queryparser")) {
  task javaccParserFlexible(type: JavaCCTask) {
    description "Regenerate Flexible query parser from queryparser/flexible/standard/parser/StandardSyntaxParser.jj"
    group "generation"

    javaccFile = file('src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.jj')
    def parentDir = javaccFile.parentFile

    doLast {
      JavaCCTask.modifyFile(file("${parentDir}/ParseException.java"), { String text ->
        // Modify constructor.
        text = text.replace(
            "class ParseException extends Exception",
            "class ParseException extends QueryNodeParseException")

        // Modify imports.
        text = text.replace(
         "package org.apache.lucene.queryparser.flexible.standard.parser;", '''\
          package org.apache.lucene.queryparser.flexible.standard.parser;

          import org.apache.lucene.queryparser.flexible.messages.*;
          import org.apache.lucene.queryparser.flexible.core.*;
          import org.apache.lucene.queryparser.flexible.core.messages.*;
          '''.stripIndent())

        // Modify constructors and code bits
        text = text.replaceAll(
          /(?s)[ ]*public ParseException\(Token currentTokenVal[^}]+[}]/, '''\
          public ParseException(Token currentTokenVal,
            int[][] expectedTokenSequencesVal, String[] tokenImageVal) 
          {
            super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, initialise(
            currentTokenVal, expectedTokenSequencesVal, tokenImageVal)));
            this.currentToken = currentTokenVal;
            this.expectedTokenSequences = expectedTokenSequencesVal;
            this.tokenImage = tokenImageVal;
          }
          '''.stripIndent().indent(2))

        text = text.replaceAll(
          /(?s)[ ]*public ParseException\(String message\)[^}]+[}]/, '''\
          public ParseException(Message message) 
          {
            super(message);
          }
          '''.stripIndent().indent(2))

        text = text.replaceAll(
          /(?s)[ ]*public ParseException\(\)[^}]+[}]/, '''\
          public ParseException() 
          {
            super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, "Error"));
          }
          '''.stripIndent().indent(2))
        return text
      })

      JavaCCTask.modifyFile(file("${parentDir}/StandardSyntaxParser.java"), { String text ->
        // Remove redundant cast
        text = text.replace(
            "new java.util.ArrayList<int[]>",
            "new java.util.ArrayList<>")
        text = text.replace(
            "new ArrayList<QueryNode>()",
            "new ArrayList<>()")
        text = text.replace(
            "Collections.<QueryNode> singletonList",
            "Collections.singletonList")
        return text
      })

      JavaCCTask.modifyFile(file("${parentDir}/StandardSyntaxParserTokenManager.java"), { String text ->
        // Remove redundant imports.
        text = text.replaceAll(
            /(?m)^import .+/,
            "")
        return text
      })
    }
  }
}

configure(project(":solr:core")) {
  task javaccSolrParser(type: JavaCCTask) {
    description "Regenerate Solr query parser from solr/parser/QueryParser.jj"
    group "generation"

    javaccFile = file('src/java/org/apache/solr/parser/QueryParser.jj')

    doLast {
      def separator = System.getProperty('line.separator')
      def parentDir = javaccFile.parentFile

      [/import java\.io\.StringReader;/,
       /import java\.util\.ArrayList;/,
       /import java\.util\.Arrays;/,
       /import java\.util\.HashSet;/,
       /import java\.util\.List;/,
       /import java\.util\.Set;/,
       /import org\.apache\.lucene\.analysis\.Analyzer;/,
       /import org\.apache\.lucene\.search\.BooleanClause;/,
       /import org\.apache\.lucene\.search\.Query;/,
       /import org\.apache\.solr\.search\.SyntaxError;/,
       /import org\.apache\.solr\.search\.QParser;/
      ].each {
        ant.replaceregexp(file: file("${parentDir}/QueryParserTokenManager.java"),
            match: "${it}\\s*${separator}",
            replace: "",
            encoding: "UTF-8")
      }

      ant.replace(file: "${parentDir}/QueryParser.java",
          token: "public QueryParser(CharStream ",
          value: "protected QueryParser(CharStream ",
          encoding: "UTF-8")

      ant.replace(file: "${parentDir}/QueryParser.java",
          token: "public QueryParser(QueryParserTokenManager ",
          value: "protected QueryParser(QueryParserTokenManager ",
          encoding: "UTF-8")

      ant.replace(file: "${parentDir}/QueryParser.java",
          token: "final private LookaheadSuccess jj_ls =",
          value: "static final private LookaheadSuccess jj_ls =",
          encoding: "UTF-8")
    }
  }
}
