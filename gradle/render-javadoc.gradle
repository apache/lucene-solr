/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// generate javadocs by calling javadoc tool
// see https://docs.oracle.com/en/java/javase/11/tools/javadoc.html

import java.util.stream.Collectors;

allprojects {
  plugins.withType(JavaPlugin) {
    // We disable the default javadoc task and have our own
    // javadoc rendering task below. The default javadoc task
    // will just invoke 'renderJavadoc' (to allow people to call
    // conventional task name).
    tasks.matching { it.name == "javadoc" }.all {
      enabled = false
      dependsOn "renderJavadoc"
    }

    task renderJavadoc(type: RenderJavadocTask) {
      description "Generates Javadoc API documentation for the main source code. This directly invokes javadoc tool."
      group "documentation"

      dependsOn sourceSets.main.compileClasspath

      srcDirSet = sourceSets.main.java;
      outputDir = project.javadoc.destinationDir;
      classpath = sourceSets.main.compileClasspath;
    }

    task renderSiteJavadoc(type: RenderJavadocTask) {
      description "Generates Javadoc API documentation for the site (relative links)."
      group "documentation"

      dependsOn sourceSets.main.compileClasspath

      srcDirSet = sourceSets.main.java;
      classpath = sourceSets.main.compileClasspath;

      relativeProjectLinks = true

      // TODO: proof of concept to place everything in one folder under root's build dir.
      def relative = project.path.replaceFirst(":", "").replace(':', '/')
      outputDir = rootProject.file("${rootProject.buildDir}/site-docs").toPath().resolve(relative).toFile()
    }
  }
}

// Fix for Java 11 Javadoc tool that cannot handle split packages between modules correctly.
// (by removing all the packages which are part of lucene-core)
// See: https://issues.apache.org/jira/browse/LUCENE-8738?focusedCommentId=16818106&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-16818106
configure(subprojects.findAll { it.path.startsWith(':lucene') && it.path != ':lucene:core' }) {
  project.tasks.withType(RenderJavadocTask) {
    doLast {
      Set luceneCorePackages = file("${project(':lucene:core').tasks[name].outputDir}/element-list").readLines('UTF-8').toSet();
      File elementFile = file("${outputDir}/element-list");
      List elements = elementFile.readLines('UTF-8');
      elements.removeAll(luceneCorePackages)
      elementFile.write(elements.join('\n').concat('\n'), 'UTF-8');
    }
  }
}

// Add cross-project documentation task dependencies and link generation.
configure(subprojects.findAll { it.path.startsWith(':lucene') && it.path != ':lucene:core' }) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(':lucene:core')
  }
}

configure(subprojects.findAll { it.path.startsWith(':lucene:analysis') && it.path != ':lucene:analysis:common'}) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(':lucene:analysis:common')
  }
}

configure(project(':lucene:benchmark')) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(
        ':lucene:memory',
        ':lucene:highlighter',
        ':lucene:analysis:common',
        ':lucene:queryparser',
        ':lucene:facet',
        ':lucene:spatial-extras')
  }
}

configure(project(':lucene:classification')) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(
       ':lucene:queries',
       ':lucene:analysis:common',
       ':lucene:grouping')
  }
}

configure(project(':lucene:demo')) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(
       ':lucene:analysis:common',
       ':lucene:queryparser',
       ':lucene:queries',
       ':lucene:facet',
       ':lucene:expressions')

    // We link the example source in the javadocs, as it's ref'ed elsewhere
    linksource = true
  }
}

configure(project(':lucene:grouping')) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(':lucene:queries')
  }
}

configure(project(':lucene:highlighter')) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(':lucene:memory')
  }
}

configure(project(':lucene:monitor')) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(
        ':lucene:memory',
        ':lucene:analysis:common',
        ':lucene:queryparser')
  }
}

configure(project(':lucene:queryparser')) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(
        ':lucene:queries',
        ':lucene:sandbox'
    )
  }
}

configure(project(':lucene:replicator')) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(':lucene:facet')
  }
}

configure(project(':lucene:spatial-extras')) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(':lucene:spatial3d')
  }
}

configure(project(':lucene:suggest')) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(':lucene:analysis:common')
  }
}

configure(project(':lucene:test-framework')) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(':lucene:codecs')
  }
}

configure(subprojects.findAll { it.path.startsWith(':solr') }) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(
        ':lucene:core',
        ':lucene:analysis:common',
        ':lucene:analysis:icu',
        ':lucene:analysis:kuromoji',
        ':lucene:analysis:nori',
        ':lucene:analysis:morfologik',
        ':lucene:analysis:phonetic',
        ':lucene:analysis:smartcn',
        ':lucene:analysis:stempel',
        ':lucene:backward-codecs',
        ':lucene:codecs',
        ':lucene:expressions',
        ':lucene:suggest',
        ':lucene:grouping',
        ':lucene:join',
        ':lucene:queries',
        ':lucene:queryparser',
        ':lucene:highlighter',
        ':lucene:memory',
        ':lucene:misc',
        ':lucene:classification',
        ':lucene:spatial-extras'
    )
  }
}

configure(project(':solr:core')) {
  project.tasks.withType(RenderJavadocTask) {
    // Specialized to ONLY depend on solrj
    addLinkedProject(':solr:solrj')
  }
}

configure(subprojects.findAll { it.path.startsWith(':solr:contrib') }) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(
        ':solr:solrj',
        ':solr:core'
    )
  }
}

configure(project(':solr:contrib:dataimporthandler-extras')) {
  project.tasks.withType(RenderJavadocTask) {
    addLinkedProject(':solr:contrib:dataimporthandler')
  }
}

configure(project(':solr:test-framework')) {
  project.tasks.withType(RenderJavadocTask) {
    linkJUnit = true
  }
}

// Disable Javadoc rendering for these projects.
configure(subprojects.findAll { it.path in [
    ':solr:solr-ref-guide',
    ':solr:server',
    ':solr:webapp']}) {
  project.tasks.withType(RenderJavadocTask) {
    enabled = false
  }
}


class RenderJavadocTask extends DefaultTask {
  @InputFiles
  @SkipWhenEmpty
  SourceDirectorySet srcDirSet;
  
  @OutputDirectory
  File outputDir

  @InputFiles
  @Classpath
  FileCollection classpath
  
  @Input
  boolean linksource = false
  
  @Input
  boolean linkJUnit = false
  
  @Input
  boolean relativeProjectLinks = false

  @Input
  def linkedProjectNames = []
  def linkedProjects = []

  @Input
  def luceneDocUrl = project.propertyOrDefault('lucene.javadoc.url', "https://lucene.apache.org/core/${project.baseVersion.replace(".", "_")}")

  @Input
  def solrDocUrl = project.propertyOrDefault('solr.javadoc.url', "https://lucene.apache.org/solr/${project.baseVersion.replace(".", "_")}")

  public addLinkedProject(String... projectPaths) {
    projectPaths.each { otherProjectPath ->
      // We want to depend on the task of the same name in the other project.
      def myName = name
      def otherProject = project.findProject(otherProjectPath)
      def otherTasks = otherProject.tasks.matching { it.name == myName }
      dependsOn otherTasks

      // Create a cross-link between documentation.
      linkedProjects.add(otherProject)
      linkedProjectNames.add(otherProjectPath)
    }
  }

  @TaskAction
  public void render() {
    def thispc = project.path.split(':').drop(1);
    // Converts absolute project path (e.g., ":lucene:analysis:common") to 
    // a link in the docs; relative to current, if needed for global documentation
    def convertPath2Link = { path ->
      def pc = path.split(':').drop(1);
      if (relativeProjectLinks) {
        int toDrop = 0;
        for (int i = 0; i < Math.min(pc.size(), thispc.size()); i++) {
          if (pc[i] == thispc[i]) {
            toDrop++;
          } else {
            break;
          }
        }
        // only create relative path if there is actually anything removed from beginning (this implies absolute link solr -> lucene):
        if (toDrop > 0) {
          return Collections.nCopies(thispc.size() - toDrop, '..').plus(pc.drop(toDrop) as List).join('/').concat('/');
        } 
      }
      return "${(pc[0] == 'lucene') ? luceneDocUrl : solrDocUrl}/${pc.drop(1).join('/')}/"
    }

    // escapes an option with single quotes or whitespace to be passed in the options.txt file for
    def escapeJavadocOption = { String s -> (s =~ /[ '"]/) ? ("'" + s.replaceAll(/[\\'"]/, /\\$0/) + "'") : s }
    
    def libName = project.path.startsWith(":lucene") ? "Lucene" : "Solr"
    def title = "${libName} ${project.version} ${project.name} API"
    
    // absolute urls for "-linkoffline" option
    def javaSEDocUrl = "https://docs.oracle.com/en/java/javase/11/docs/api/"
    def junitDocUrl = "https://junit.org/junit4/javadoc/4.12/"

    def javadocCmd = org.gradle.internal.jvm.Jvm.current().getJavadocExecutable()

    def srcDirs = srcDirSet.srcDirs.findAll { dir -> dir.exists() }
    def optionsFile = project.file("${getTemporaryDir()}/javadoc-options.txt")
    
    def opts = []
    opts << [ '-overview', project.file("${srcDirs[0]}/overview.html") ]
    opts << [ '-sourcepath', srcDirs.join(File.pathSeparator) ]
    opts << [ '-subpackages', project.path.startsWith(':lucene') ? 'org.apache.lucene' : 'org.apache.solr' ]
    opts << [ '-d', outputDir ]
    opts << '-protected'
    opts << [ '-encoding', 'UTF-8' ]
    opts << [ '-charset', 'UTF-8' ]
    opts << [ '-docencoding', 'UTF-8' ]
    opts << '-noindex'
    opts << '-author'
    opts << '-version'
    if (linksource) {
      opts << '-linksource'
    }
    opts << '-use'
    opts << [ '-locale', 'en_US' ]
    opts << [ '-windowtitle', title ]
    opts << [ '-doctitle', title ]
    if (!classpath.isEmpty()) {
      opts << [ '-classpath', classpath.asPath ]
    }
    opts << [ '-bottom', "<i>Copyright &copy; 2000-${project.buildYear} Apache Software Foundation. All Rights Reserved.</i>" ]

    opts << [ '-tag', 'lucene.experimental:a:WARNING: This API is experimental and might change in incompatible ways in the next release.' ]
    opts << [ '-tag', 'lucene.internal:a:NOTE: This API is for internal purposes only and might change in incompatible ways in the next release.' ]
    opts << [ '-tag', "lucene.spi:t:SPI Name (case-insensitive: if the name is 'htmlStrip', 'htmlstrip' can be used when looking up the service)." ]

    // resolve links to JavaSE and JUnit API
    opts << [ '-linkoffline', javaSEDocUrl, project.project(':lucene').file('tools/javadoc/java11/') ]
    if (linkJUnit) {
      opts << [ '-linkoffline', junitDocUrl, project.project(':lucene').file('tools/javadoc/junit/') ]
    }

    // Resolve inter-project links.
    linkedProjects.collect { otherProject ->
      def docdir = convertPath2Link(otherProject.path)
      opts << [ '-linkoffline', docdir, otherProject.tasks[name].outputDir ]
    }

    opts << [ '--release', 11 ]
    opts << '-Xdoclint:all,-missing'

    // Temporary file that holds all javadoc options for the current task.
    String optionsStr = opts.stream()
      .map{ (it instanceof List) ? it.stream().map{it as String}.map(escapeJavadocOption).collect(Collectors.joining(' ')) : escapeJavadocOption(it as String)}
      .collect(Collectors.joining('\n'));
    optionsFile.write(optionsStr, 'UTF-8')

    def outputFile = project.file("${getTemporaryDir()}/javadoc-output.txt")
    def result
    outputFile.withOutputStream { output ->
      result = project.exec {
        executable javadocCmd

        standardOutput = output
        errorOutput = output

        args += [ "@${optionsFile}" ]

        // -J flags can't be passed via options file... (an error "javadoc: error - invalid flag: -J-Xmx512m" occurs.)
        args += [ "-J-Xmx512m" ]
        // force locale to be "en_US" (fix for: https://bugs.openjdk.java.net/browse/JDK-8222793)
        args += [ "-J-Duser.language=en", "-J-Duser.country=US" ]

        ignoreExitValue true
      }
    }

    if (result.getExitValue() != 0) {
      // Pipe the output to console. Intentionally skips any encoding conversion 
      // and pumps raw bytes.
      System.out.write(outputFile.bytes)

      def cause
      try {
        result.rethrowFailure()
      } catch (ex) {
        cause = ex
      }
      throw new GradleException("Javadoc generation failed for ${project.path},\n  Options file at: ${optionsFile}\n  Command output at: ${outputFile}", cause)
    }

    // append some special table css, prettify css
    ant.concat(destfile: "${outputDir}/stylesheet.css", append: "true", fixlastline: "true", encoding: "UTF-8") {
      filelist(dir: project.project(":lucene").file("tools/javadoc"), files: "table_padding.css")
      filelist(dir: project.project(":lucene").file("tools/prettify"), files: "prettify.css")
    }
    // append prettify to scripts
    ant.concat(destfile: "${outputDir}/script.js", append: "true", fixlastline: "true", encoding: "UTF-8") {
      filelist(dir: project.project(':lucene').file("tools/prettify"), files: "prettify.js inject-javadocs.js")
    }
    ant.fixcrlf(srcdir: outputDir, includes: "stylesheet.css script.js", eol: "lf", fixlast: "true", encoding: "UTF-8")
  }
}
