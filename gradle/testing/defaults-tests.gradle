import org.apache.tools.ant.taskdefs.condition.Os
import org.gradle.api.tasks.testing.logging.*

import java.util.concurrent.ConcurrentHashMap

def verboseModeHookInstalled = false

allprojects {
  plugins.withType(JavaPlugin) {
    def verboseMode = Boolean.parseBoolean(propertyOrDefault("tests.verbose", "false"))

    project.ext {
      testsWorkDir = file("${buildDir}/tmp/tests-cwd")
      testsTmpDir = file("${buildDir}/tmp/tests-tmp")
      commonDir = project(":lucene").projectDir
      commonSolrDir = project(":solr").projectDir
    }

    // If we're running in verbose mode and:
    // 1) worker count > 1
    // 2) number of 'test' tasks in the build is > 1
    // then the output would very likely be mangled on the
    // console. Fail and let the user know what to do.
    if (verboseMode && !verboseModeHookInstalled) {
      verboseModeHookInstalled = true
      if (gradle.startParameter.maxWorkerCount > 1) {
        gradle.taskGraph.whenReady { graph ->
          def testTasks = graph.allTasks.findAll { task -> task instanceof Test }
          if (testTasks.size() > 1) {
            throw new GradleException("Run your tests in verbose mode only with --max-workers=1 option passed to gradle.")
          }
        }
      }
    }

    test {
      if (verboseMode) {
        maxParallelForks = 1
      } else {
        maxParallelForks = propertyOrDefault("tests.jvms", (int) Math.max(1, Math.min(Runtime.runtime.availableProcessors() / 2.0, 4.0)))
      }

      workingDir testsWorkDir
      useJUnit()

      minHeapSize = "256m"
      maxHeapSize = "512m"

      systemProperty 'java.util.logging.config.file', file("${commonDir}/tools/junit4/logging.properties")
      systemProperty 'java.awt.headless', 'true'
      systemProperty 'jdk.map.althashing.threshold', '0'

      if (!Os.isFamily(Os.FAMILY_WINDOWS)) {
        systemProperty 'java.security.egd', 'file:/dev/./urandom'
      }

      // jetty-related.
      systemProperty 'jetty.testMode', '1'
      systemProperty 'jetty.insecurerandom', '1'

      // Turn jenkins blood red for hashmap bugs, even on jdk7
      systemProperty 'jdk.map.althashing.threshold', '0'

      // Pass these to RandomizedRunner so that it doesn't attempt to set them.
      systemProperty 'junit4.childvm.count', '1'
      systemProperty 'junit4.childvm.id', '0'

      // Set up cwd and temp locations.
      systemProperty("java.io.tmpdir", testsTmpDir)
      systemProperty("tempDir", testsTmpDir)
      doFirst {
        testsWorkDir.mkdirs()
        testsTmpDir.mkdirs()
      }

      // Set up logging.
      if (verboseMode) {
        testLogging {
          events TestLogEvent.FAILED
          exceptionFormat TestExceptionFormat.FULL
          showExceptions true
          showCauses true
          showStackTraces true
          showStandardStreams = false
        }
        onOutput { td, event ->
          print event.message
        }
      } else {
        testLogging {
          events TestLogEvent.FAILED
          exceptionFormat TestExceptionFormat.FULL
          showExceptions true
          showCauses true
          showStackTraces true
        }

        Map<String, ? extends Collection<String>> testOutput = new ConcurrentHashMap<>()

        onOutput { td, event ->
          // This is our 'reproduce with' line, print it immediately, which will be right after the test failure message
          if (event.destination == TestOutputEvent.Destination.StdErr && event.message.startsWith("NOTE: reproduce")) {
            logger.error event.message
          }

          // TODO spill output to a file
          if (event.message != null) {
            String key = td.className + td.name
            testOutput.computeIfAbsent(key, { k -> new ArrayList<String>() }).add(event.message)
          }
        }

        afterTest { td, result ->
          String key = td.className + td.name;
          if (result.resultType == TestResult.ResultType.FAILURE) {
            // This will print the test output, but not anything that comes from the suite (i.e. beforeTest or afterTest)
            // Note that this output is printed before the corresponding failure trace, not sure it that is expected or not
            def output = testOutput.get(key)
            if (output != null) {
              // need to strip trailing because unfortunately we saved the newline character earlier
              output.forEach { s -> logger.error(s.stripTrailing()) }
            }
          }
          // Be careful with how much output we are buffering in memory - clean up!
          testOutput.remove(key)
        }
        afterSuite { suite, result ->
          if (result.resultType == TestResult.ResultType.FAILURE) {
            if (suite.name.equals(suite.className)) { // Act on single classes, not on whole suites
              // This will print failure info from before/after the test, including 'reproduce with' lines
              // We might not need it since we have the reproduce line printed with the failure
              // testOutput.get(suite.className + suite.name).forEach({ s -> logger.error(s) })
            }
          }
        }
      }

      doFirst {
        // Print some diagnostics about locations used.
        logger.info("Test folders for {}: cwd={}, tmp={}", project.path, testsWorkDir, testsTmpDir)
      }
    }
  }
}
