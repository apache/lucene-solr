import org.apache.tools.ant.taskdefs.condition.Os
import org.gradle.api.tasks.testing.logging.*

import java.util.concurrent.ConcurrentHashMap

def verboseModeHookInstalled = false

allprojects {
  plugins.withType(JavaPlugin) {
    def verboseMode = Boolean.parseBoolean(propertyOrDefault("tests.verbose", "false"))

    project.ext {
      testsWorkDir = file("${buildDir}/tmp/tests-cwd")
      testsTmpDir = file("${buildDir}/tmp/tests-tmp")
      commonDir = project(":lucene").projectDir
      commonSolrDir = project(":solr").projectDir
    }

    // If we're running in verbose mode and:
    // 1) worker count > 1
    // 2) number of 'test' tasks in the build is > 1
    // then the output would very likely be mangled on the
    // console. Fail and let the user know what to do.
    if (verboseMode && !verboseModeHookInstalled) {
      verboseModeHookInstalled = true
      if (gradle.startParameter.maxWorkerCount > 1) {
        gradle.taskGraph.whenReady { graph ->
          def testTasks = graph.allTasks.findAll { task -> task instanceof Test }
          if (testTasks.size() > 1) {
            throw new GradleException("Run your tests in verbose mode only with --max-workers=1 option passed to gradle.")
          }
        }
      }
    }

    test {
      if (verboseMode) {
        maxParallelForks = 1
      } else {
        maxParallelForks = propertyOrDefault("tests.jvms", (int) Math.max(1, Math.min(Runtime.runtime.availableProcessors() / 2.0, 4.0)))
      }

      workingDir testsWorkDir
      useJUnit()

      minHeapSize = "256m"
      maxHeapSize = "512m"

      systemProperty 'java.util.logging.config.file', file("${commonDir}/tools/junit4/logging.properties")
      systemProperty 'java.awt.headless', 'true'
      systemProperty 'jdk.map.althashing.threshold', '0'

      if (!Os.isFamily(Os.FAMILY_WINDOWS)) {
        systemProperty 'java.security.egd', 'file:/dev/./urandom'
      }

      // jetty-related.
      systemProperty 'jetty.testMode', '1'
      systemProperty 'jetty.insecurerandom', '1'

      // Turn jenkins blood red for hashmap bugs, even on jdk7
      systemProperty 'jdk.map.althashing.threshold', '0'

      // Pass these to RandomizedRunner so that it doesn't attempt to set them.
      systemProperty 'junit4.childvm.count', '1'
      systemProperty 'junit4.childvm.id', '0'

      // Set up cwd and temp locations.
      systemProperty("java.io.tmpdir", testsTmpDir)
      systemProperty("tempDir", testsTmpDir)
      doFirst {
        testsWorkDir.mkdirs()
        testsTmpDir.mkdirs()
      }

      // Set up logging.
      if (verboseMode) {
        testLogging {
          events TestLogEvent.FAILED
          exceptionFormat TestExceptionFormat.FULL
          showExceptions true
          showCauses true
          showStackTraces true
          showStandardStreams = false
        }
        onOutput { td, event ->
          print event.message
        }
      } else {
        testLogging {
          events TestLogEvent.FAILED
          exceptionFormat TestExceptionFormat.FULL
          showExceptions true
          showCauses true
          showStackTraces true
        }

        Map<String, TestOutputBuffer> testOutput = new ConcurrentHashMap<>()

        onOutput { td, event ->
          if (event.message != null) {
            if (event.destination == TestOutputEvent.Destination.StdErr && event.message.startsWith("NOTE: reproduce")) {
              // This is our 'reproduce with' line, print it immediately, which will be right after the test failure message
              logger.error event.message
            }
            String key = td.className + td.name
            testOutput.computeIfAbsent(key, { k -> new TestOutputBuffer(testsTmpDir, k) }).add(event)
          }
        }

        afterTest { td, result ->
          String key = td.className + td.name;
          testOutput.get(key).withCloseable { output ->
            if (result.resultType == TestResult.ResultType.FAILURE) {
              // This will print the test output, but not anything that comes from the suite (i.e. beforeTest or afterTest)
              // Note that this output is printed before the corresponding failure trace, not sure it that is expected or not
              output?.log(logger)
            }
          }
          testOutput.remove(key)
        }
        afterSuite { suite, result ->
          if (result.resultType == TestResult.ResultType.FAILURE) {
            if (suite.name.equals(suite.className)) { // Act on single classes, not on whole suites
              // This will print failure info from before/after the test, including 'reproduce with' lines
              // We might not need it since we have the reproduce line printed with the failure
              // testOutput.get(suite.className + suite.name).forEach({ s -> logger.error(s) })
            }
          }
        }
      }

      doFirst {
        // Print some diagnostics about locations used.
        logger.info("Test folders for {}: cwd={}, tmp={}", project.path, testsWorkDir, testsTmpDir)
      }
    }
  }
}

class TestOutputBuffer implements Closeable {
  private final File outputFile;
  private final Writer writer;

  TestOutputBuffer(File outputDirectory, String key) {
    this.outputFile = new File(outputDirectory, key + ".out");
    try {
      FileOutputStream fos = new FileOutputStream(this.outputFile);
      this.writer = new PrintWriter(new BufferedOutputStream(fos));
    } catch (IOException e) {
      throw new UncheckedIOException("Unable to create test suite output file", e);
    }
  }

  void add(TestOutputEvent event) {
    String prefix;
    if (event.destination == TestOutputEvent.Destination.StdOut) {
      prefix = "  1> ";
    } else {
      prefix = "  2> ";
    }

    try {
      writer.write(prefix + event.message);
    } catch (IOException e) {
      throw new UncheckedIOException("Unable to write test suite output", e);
    }
  }

  void log(Logger logger) {
    outputFile.eachLine { line ->
      logger.error(line)
    }
  }

  @Override
  void close() throws IOException {
    writer.close();
    outputFile.delete();
  }
}
