<?xml version="1.0"?>

<!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->

<project name="common" xmlns:artifact="antlib:org.apache.maven.artifact.ant" 
                       xmlns:ivy="antlib:org.apache.ivy.ant"
                       xmlns:junit4="antlib:com.carrotsearch.junit4"
                       xmlns:jacoco="antlib:org.jacoco.ant"
                       xmlns:rsel="antlib:org.apache.tools.ant.types.resources.selectors">
  <description>
    This file is designed for importing into a main build file, and not intended
    for standalone use.
  </description>

  <dirname file="${ant.file.common}" property="common.dir"/>
  
  <!-- Give user a chance to override without editing this file
      (and without typing -D each time it compiles it -->
  <property file="${user.home}/lucene.build.properties"/>
  <property file="${user.home}/build.properties"/>
  <property file="${common.dir}/build.properties"/>

  <property name="dev-tools.dir" location="${common.dir}/../dev-tools"/>
  <property name="prettify.dir" location="${common.dir}/tools/prettify"/>
  <property name="license.dir" location="${common.dir}/licenses"/>
  <property name="ivysettings.xml" location="${common.dir}/default-nested-ivy-settings.xml"/>

  <tstamp>
    <format property="current.year" pattern="yyyy"/>
    <format property="DSTAMP" pattern="yyyy-MM-dd"/>
    <format property="TSTAMP" pattern="HH:mm:ss"/>
    <!-- datetime format that is safe to treat as part of a dotted version -->
    <format property="dateversion" pattern="yyyy.MM.dd.HH.mm.ss" />
  </tstamp>

  <property name="Name" value="Lucene"/>
  <property name="name" value="${ant.project.name}"/>
  
  <!-- include version number from property file (includes "version.*" properties) -->
  <loadproperties srcFile="${common.dir}/version.properties"/>
  
  <fail message="'version.base' property must be 'x.y.z' (major, minor, bugfix) or 'x.y.z.1/2' (+ prerelease) and numeric only: ${version.base}">
    <condition>
      <not><matches pattern="^\d+\.\d+\.\d+(|\.1|\.2)$" casesensitive="true" string="${version.base}"/></not>
    </condition>
  </fail>

  <fail message="If you pass -Dversion=... to set a release version, it must match &quot;${version.base}&quot;, optionally followed by a suffix (e.g., &quot;-SNAPSHOT&quot;).">
    <condition>
      <not><matches pattern="^\Q${version.base}\E(|\-.*)$" casesensitive="true" string="${version}"/></not>
    </condition>
  </fail>

  <property name="year" value="2000-${current.year}"/>
  
  <!-- Lucene modules unfortunately don't have the "lucene-" prefix, so we add it if no prefix is given in $name: -->
  <condition property="final.name" value="${name}-${version}" else="lucene-${name}-${version}">
    <matches pattern="^(lucene|solr)\b" string="${name}"/>
  </condition>

  <!-- we exclude ext/*.jar because we don't want example/lib/ext logging jars on the cp -->
  <property name="common.classpath.excludes" value="**/*.txt,**/*.template,**/*.sha1,ext/*.jar" />

  <property name="build.dir" location="build"/>
  <!-- Needed in case a module needs the original build, also for compile-tools to be called from a module -->
  <property name="common.build.dir" location="${common.dir}/build"/>

  <property name="ivy.bootstrap.version" value="2.3.0" /> <!-- UPGRADE NOTE: update disallowed.ivy.jars regex in ivy-availability-check -->
  <property name="ivy.default.configuration" value="*"/>

  <!-- Running ant targets in parralel may require this set to false because ivy:retrieve tasks may race with resolve -->
  <property name="ivy.sync" value="true"/>
  <property name="ivy.resolution-cache.dir" location="${common.build.dir}/ivy-resolution-cache"/>
  <property name="ivy.lock-strategy" value="artifact-lock"/>

  <property name="local.caches" location="${common.dir}/../.caches" />
  <property name="tests.cachedir"  location="${local.caches}/test-stats" />
  <property name="tests.cachefile" location="${common.dir}/tools/junit4/cached-timehints.txt" />
  <property name="tests.cachefilehistory" value="10" />

  <path id="junit-path">
    <fileset dir="${common.dir}/test-framework/lib"/>
  </path>

  <!-- default arguments to pass to JVM executing tests -->
  <property name="args" value=""/>

  <property name="tests.seed" value="" />

  <!-- This is a hack to be able to override the JVM count for special modules that don't like parallel tests: -->
  <property name="tests.jvms" value="auto" />
  <property name="tests.jvms.override" value="${tests.jvms}" />

  <property name="tests.multiplier" value="1" />
  <property name="tests.codec" value="random" />
  <property name="tests.postingsformat" value="random" />
  <property name="tests.docvaluesformat" value="random" />
  <property name="tests.locale" value="random" />
  <property name="tests.timezone" value="random" />
  <property name="tests.directory" value="random" />
  <property name="tests.linedocsfile" value="europarl.lines.txt.gz" />
  <property name="tests.loggingfile" location="${common.dir}/tools/junit4/logging.properties"/>
  <property name="tests.nightly" value="false" />
  <property name="tests.weekly" value="false" />
  <property name="tests.monster" value="false" />
  <property name="tests.slow" value="true" />
  <property name="tests.cleanthreads.sysprop" value="perMethod"/>
  <property name="tests.verbose" value="false"/>
  <property name="tests.infostream" value="${tests.verbose}"/>
  <property name="tests.filterstacks" value="true"/>
  <property name="tests.luceneMatchVersion" value="${version.base}"/>
  <property name="tests.asserts" value="true" />
  <property name="tests.policy" location="${common.dir}/tools/junit4/tests.policy"/>

  <condition property="tests.asserts.args" value="-ea -esa" else="">
    <istrue value="${tests.asserts}"/>
  </condition>

  <condition property="tests.heapsize" value="768M" else="512M">
    <isset property="run.clover"/>
  </condition>
  
  <condition property="tests.clover.args" value="-XX:ReservedCodeCacheSize=128m -XX:MaxPermSize=192m" else="">
    <isset property="run.clover"/>
  </condition>

  <!-- Override these in your local properties to your desire. -->
  <!-- Show simple class names (no package) in test suites. -->
  <property name="tests.useSimpleNames" value="false" />
  <!-- Max width for class name truncation.  -->
  <property name="tests.maxClassNameColumns" value="10000" />
  <!-- Show suite summaries for tests. -->
  <property name="tests.showSuiteSummary" value="true" />
  <!-- Show timestamps in console test reports. -->
  <property name="tests.timestamps" value="false" />
  <!-- Heartbeat in seconds for reporting long running tests or hung forked JVMs. -->
  <property name="tests.heartbeat" value="60" />

  <!-- Configure test emission to console for each type of status -->
  <property name="tests.showError" value="true" />
  <property name="tests.showFailure" value="true" />
  <property name="tests.showIgnored" value="true" />

  <!-- Display at most this many failures as a summary at the end of junit4 run. -->
  <property name="tests.showNumFailures" value="10" />

  <property name="javac.deprecation" value="off"/>
  <property name="javac.debug" value="on"/>
  <property name="javac.release" value="8"/>
  <property name="javac.args" value="-Xlint -Xlint:-deprecation -Xlint:-serial"/>
  <property name="javac.profile.args" value="-profile compact2"/>
  <property name="javadoc.link" value="https://docs.oracle.com/javase/8/docs/api/"/>
  <property name="javadoc.link.junit" value="http://junit.sourceforge.net/javadoc/"/>
  <property name="javadoc.packagelist.dir" location="${common.dir}/tools/javadoc"/>
  <available file="${javadoc.packagelist.dir}/java8/package-list" property="javadoc.java8.packagelist.exists"/>
  <property name="javadoc.access" value="protected"/>
  <property name="javadoc.charset" value="utf-8"/>
  <property name="javadoc.dir" location="${common.dir}/build/docs"/>
  <property name="javadoc.maxmemory" value="512m" />
  <property name="javadoc.noindex" value="true"/>

  <property name="javadoc.doclint.args" value="-Xdoclint:all -Xdoclint:-missing"/>
  <property name="javac.doclint.args" value="-Xdoclint:all/protected -Xdoclint:-missing"/>
  
  <!-- Javadoc classpath -->
  <path id="javadoc.classpath">
    <path refid="classpath"/>
    <pathelement location="${ant.home}/lib/ant.jar"/>
    <fileset dir=".">
      <exclude name="build/**/*.jar"/>
      <include name="**/lib/*.jar"/>
    </fileset>
  </path>
  
  <property name="changes.src.dir" location="${common.dir}/site/changes"/>
  <property name="changes.target.dir" location="${common.dir}/build/docs/changes"/>

  <property name="project.name" value="site"/> <!-- todo: is this used by anakia or something else? -->
  <property name="build.encoding" value="utf-8"/>

  <property name="src.dir" location="src/java"/>
  <property name="resources.dir" location="${src.dir}/../resources"/>
  <property name="tests.src.dir" location="src/test"/>
  <available property="module.has.tests" type="dir" file="${tests.src.dir}"/>
  <property name="dist.dir" location="${common.dir}/dist"/>
  <property name="maven.dist.dir" location="${dist.dir}/maven"/>
  <makeurl file="${maven.dist.dir}" property="m2.repository.url" validate="false"/>
  <property name="m2.repository.private.key" value="${user.home}/.ssh/id_dsa"/>
  <property name="m2.repository.id" value="local"/>
  <property name="m2.credentials.prompt" value="true"/>

  <property name="tests.workDir" location="${build.dir}/test"/>
  <property name="junit.output.dir" location="${build.dir}/test"/>
  <property name="junit.reports" location="${build.dir}/test/reports"/>

  <property name="manifest.file" location="${build.dir}/MANIFEST.MF"/>

  <property name="git.exe" value="git" />
  <property name="perl.exe" value="perl" />
  
  <property name="python.exe" value="python" />
  <!-- todo: rename this variable -->
  <property name="python32.exe" value="python3" />

  <property name="gpg.exe" value="gpg" />
  <property name="gpg.key" value="CODE SIGNING KEY" />

  <property name="filtered.pom.templates.dir" location="${common.dir}/build/poms"/>

  <property name="clover.license.path" location="${common.dir}/tools/clover/clover.license"/>
  <property name="clover.db.dir" location="${common.dir}/build/clover/db"/>
  <property name="clover.report.dir" location="${common.dir}/build/clover/reports"/>

  <property name="jacoco.report.dir" location="${common.dir}/build/jacoco"/>

  <property name="pitest.report.dir" location="${common.dir}/build/pitest/${name}/reports"/>
  <property name="pitest.distance" value="0" />
  <property name="pitest.threads" value="2" />
  <property name="pitest.testCases" value="org.apache.*" />
  <property name="pitest.maxMutations" value="0" />
  <property name="pitest.timeoutFactor" value="1.25" />
  <property name="pitest.timeoutConst" value="3000" />
  <property name="pitest.targetClasses" value="org.apache.*" />

  <!-- a reasonable default exclusion set, can be overridden for special cases -->
  <property name="rat.excludes" value="**/TODO,**/*.txt,**/*.iml"/>
  
  <!-- These patterns can be defined to add additional files for checks, relative to module's home dir -->
  <property name="rat.additional-includes" value=""/>
  <property name="rat.additional-excludes" value=""/>

  <propertyset id="uptodate.and.compiled.properties" dynamic="true">
    <propertyref regex=".*\.uptodate$$"/>
    <propertyref regex=".*\.compiled$$"/>
    <propertyref regex=".*\.loaded$$"/>
    <propertyref name="lucene.javadoc.url"/><!-- for Solr -->
    <propertyref name="tests.totals.tmpfile" />
    <propertyref name="git-autoclean.disabled"/>
  </propertyset>

  <patternset id="lucene.local.src.package.patterns"
              excludes="**/pom.xml,**/*.iml,**/*.jar,build/**,dist/**,benchmark/work/**,benchmark/temp/**,tools/javadoc/java8/**,tools/clover/**"
  />

  <!-- Default exclude sources and javadoc jars from Ivy fetch to save time and bandwidth -->
  <condition property="ivy.exclude.types" 
      value=""
      else="source|javadoc">
    <isset property="fetch.sources.javadocs"/>
  </condition>

  <!-- Check for minimum supported ANT version. -->
  <fail message="Minimum supported ANT version is 1.8.2. Yours: ${ant.version}">
    <condition>
      <not><antversion atleast="1.8.2" /></not>
    </condition>
  </fail>

  <fail message="Minimum supported Java version is 1.8.">
    <condition>
      <not><hasmethod classname="java.util.Arrays" method="parallelSort"/></not>
    </condition>
  </fail>

  <!-- temporary for cleanup of java.specification.version, to be in format "x.y" -->
  <loadresource property="-cleaned.specification.version">
    <propertyresource name="java.specification.version"/>
    <filterchain>
      <tokenfilter>
        <filetokenizer/>
        <replaceregex pattern="^(\d+\.\d+)(|\..*)$" replace="\1" flags="s"/>
      </tokenfilter>
    </filterchain>
  </loadresource>

  <!-- 
    the propery "ant.java.version" is not always correct, depending on used ANT version.
    E.g. Java 8 is only detected in ANT 1.8.3+.
    
    We want to detect here only a limited set of versions and placed in normalized form in ${build.java.runtime},
    every other version is normalized to "unknown":
    - To define a target to be only run on a specific version, add <equals/> condition to one of the supplied versions.
    - To explicitely exclude specific versions (and unknown ones), add a condition to disallow "unknown" and some versions like "1.9"/"9"!
    - For Java 9, be sure to exclude both in custom checks: "9" and "1.9"
    
    TODO: Find a better solution in Ant without scripting to check supported Java versions!
   -->
  <condition property="build.java.runtime" value="${-cleaned.specification.version}" else="unknown">
    <or>
      <equals arg1="${-cleaned.specification.version}" arg2="1.8"/>
      <equals arg1="${-cleaned.specification.version}" arg2="1.9"/>
      <equals arg1="${-cleaned.specification.version}" arg2="9"/>
    </or>
  </condition>
  
  <!--
  <echo message="DEBUG: Cleaned java.specification.version=${-cleaned.specification.version}"/>
  <echo message="DEBUG: Detected runtime: ${build.java.runtime}"/>
  -->
  
  <condition property="documentation-lint.supported">
    <and>
      <or>
        <contains string="${java.vm.name}" substring="hotspot" casesensitive="false"/>
        <contains string="${java.vm.name}" substring="openjdk" casesensitive="false"/>
        <contains string="${java.vm.name}" substring="jrockit" casesensitive="false"/>
      </or>
      <equals arg1="${build.java.runtime}" arg2="1.8"/>
      <!-- TODO: Fix this! For now only run this on 64bit, because jTIDY OOMs with default heap size: -->
      <contains string="${os.arch}" substring="64"/>
    </and>
  </condition>

  <!-- workaround for https://issues.apache.org/bugzilla/show_bug.cgi?id=53347 -->
  <condition property="build.compiler" value="javac1.7">
    <or>
      <antversion exactly="1.8.3" />
      <antversion exactly="1.8.4" />
    </or>
  </condition>

  <target name="-documentation-lint-unsupported" unless="documentation-lint.supported">
    <fail message="Linting documentation HTML is not supported on this Java version (${build.java.runtime}) / JVM (${java.vm.name}).">
      <condition>
        <not><isset property="is.jenkins.build"/></not>
      </condition>
    </fail>
    <echo level="warning" message="WARN: Linting documentation HTML is not supported on this Java version (${build.java.runtime}) / JVM (${java.vm.name}). NOTHING DONE!"/>
  </target>

  <!-- Import custom ANT tasks. -->
  <import file="${common.dir}/tools/custom-tasks.xml" />

  <target name="clean"
    description="Removes contents of build and dist directories">
    <delete dir="${build.dir}"/>
    <delete dir="${dist.dir}"/>
    <delete file="velocity.log"/>
  </target>

  <target name="init" depends="git-autoclean,resolve">
    <!-- currently empty -->
  </target>
  
  <!-- Keep track of GIT branch and do "ant clean" on root folder when changed, to prevent bad builds... -->
  
  <property name="gitHeadFile" location="${common.dir}/../.git/HEAD"/>
  <property name="gitHeadLocal" location="${common.dir}/build/git-HEAD"/>
  <available file="${gitHeadFile}" property="isGitCheckout"/>

  <target name="git-autoclean" depends="-check-git-state,-git-cleanroot,-copy-git-state"/>
  
  <target name="-check-git-state" if="isGitCheckout" unless="git-autoclean.disabled">
    <condition property="gitHeadChanged">
      <and>
        <available file="${gitHeadLocal}"/>
        <not><filesmatch file1="${gitHeadFile}" file2="${gitHeadLocal}"/></not>
      </and>
    </condition>
  </target>

  <target name="-git-cleanroot" depends="-check-git-state" if="gitHeadChanged" unless="git-autoclean.disabled">
    <echo message="Git branch changed, cleaning up for sane build..."/>
    <ant dir="${common.dir}/.." target="clean" inheritall="false">
      <propertyset refid="uptodate.and.compiled.properties"/>
    </ant>
  </target>
  
  <target name="-copy-git-state" if="isGitCheckout" unless="git-autoclean.disabled">
    <mkdir dir="${common.dir}/build"/>
    <copy file="${gitHeadFile}" tofile="${gitHeadLocal}"/>
    <property name="git-autoclean.disabled" value="true"/>
  </target>

  <!-- IVY stuff -->

  <target name="ivy-configure">
     <!-- [DW] ivy loses its configuration for some reason. cannot explain this. if
          you have an idea, fix it.
          unless="ivy.settings.uptodate" -->
    <!-- override: just for safety, should be unnecessary -->
    <ivy:configure file="${common.dir}/top-level-ivy-settings.xml" override="true"/>
    <!-- <property name="ivy.settings.uptodate" value="true"/> -->
  </target>

  <condition property="ivy.symlink">
    <os family="unix"/>
  </condition>

  <target name="resolve" depends="ivy-availability-check,ivy-configure">
    <!-- todo, make this a property or something. 
         only special cases need bundles -->
    <ivy:retrieve type="jar,bundle,test,test-jar,tests" log="download-only" symlink="${ivy.symlink}"
                  conf="${ivy.default.configuration}" sync="${ivy.sync}"/>
  </target>

  <property name="ivy_install_path" location="${user.home}/.ant/lib" />
  <property name="ivy_bootstrap_url1" value="http://repo1.maven.org/maven2"/>
  <!-- you might need to tweak this from china so it works -->
  <property name="ivy_bootstrap_url2" value="http://uk.maven.org/maven2"/>
  <property name="ivy_checksum_sha1" value="c5ebf1c253ad4959a29f4acfe696ee48cdd9f473"/>

  <target name="ivy-availability-check" unless="ivy.available">
    <path id="disallowed.ivy.jars">
      <fileset dir="${ivy_install_path}">
        <filename regex="ivy-2\.[012].*\.jar"/> <!-- TODO: Update this regex to disallow Ivy versions -->
      </fileset>
    </path>
    <loadresource property="disallowed.ivy.jars.list">
      <string value="${toString:disallowed.ivy.jars}"/>
      <filterchain><tokenfilter><replacestring from="jar:" to="jar, "/></tokenfilter></filterchain>
    </loadresource>
    <condition property="disallowed.ivy.jar.found">
      <resourcecount when="greater" count="0">
        <path refid="disallowed.ivy.jars"/>
      </resourcecount>
    </condition>
    <antcall target="-ivy-fail-disallowed-ivy-version"/>

    <condition property="ivy.available">
      <typefound uri="antlib:org.apache.ivy.ant" name="configure" />
    </condition>
    <antcall target="ivy-fail" />
  </target>

  <target name="-ivy-fail-disallowed-ivy-version" if="disallowed.ivy.jar.found">
    <sequential>
      <echo message="Please delete the following disallowed Ivy jar(s): ${disallowed.ivy.jars.list}"/>
      <fail>Found disallowed Ivy jar(s): ${disallowed.ivy.jars.list}</fail>
    </sequential>
  </target>

  <target name="ivy-fail" unless="ivy.available">
   <echo>
     This build requires Ivy and Ivy could not be found in your ant classpath.

     (Due to classpath issues and the recursive nature of the Lucene/Solr 
     build system, a local copy of Ivy can not be used an loaded dynamically 
     by the build.xml)

     You can either manually install a copy of Ivy ${ivy.bootstrap.version} in your ant classpath:
       http://ant.apache.org/manual/install.html#optionalTasks

     Or this build file can do it for you by running the Ivy Bootstrap target:
       ant ivy-bootstrap     
     
     Either way you will only have to install Ivy one time.

     'ant ivy-bootstrap' will install a copy of Ivy into your Ant User Library:
       ${user.home}/.ant/lib
     
     If you would prefer, you can have it installed into an alternative 
     directory using the "-Divy_install_path=/some/path/you/choose" option, 
     but you will have to specify this path every time you build Lucene/Solr 
     in the future...
       ant ivy-bootstrap -Divy_install_path=/some/path/you/choose
       ...
       ant -lib /some/path/you/choose clean compile
       ...
       ant -lib /some/path/you/choose clean compile

     If you have already run ivy-bootstrap, and still get this message, please 
     try using the "--noconfig" option when running ant, or editing your global
     ant config to allow the user lib to be loaded.  See the wiki for more details:
       http://wiki.apache.org/lucene-java/DeveloperTips#Problems_with_Ivy.3F
    </echo>
    <fail>Ivy is not available</fail>
  </target>

  <target name="ivy-bootstrap" description="Download and install Ivy in the users ant lib dir" depends="ivy-bootstrap1,ivy-bootstrap2,ivy-checksum"/>

  <!-- try to download from repo1.maven.org -->
  <target name="ivy-bootstrap1">
    <ivy-download src="${ivy_bootstrap_url1}" dest="${ivy_install_path}"/>
    <available file="${ivy_install_path}/ivy-${ivy.bootstrap.version}.jar" property="ivy.bootstrap1.success" />
  </target> 

  <target name="ivy-bootstrap2" unless="ivy.bootstrap1.success">
    <ivy-download src="${ivy_bootstrap_url2}" dest="${ivy_install_path}"/>
  </target>

  <target name="ivy-checksum">
    <checksum file="${ivy_install_path}/ivy-${ivy.bootstrap.version}.jar"
              property="${ivy_checksum_sha1}"
              algorithm="SHA"
              verifyproperty="ivy.checksum.success"/>
    <fail message="Checksum mismatch for ivy-${ivy.bootstrap.version}.jar. Please download this file manually">
      <condition>
        <isfalse value="${ivy.checksum.success}"/>
      </condition>
    </fail>
  </target>
   
  <macrodef name="ivy-download">
      <attribute name="src"/>
      <attribute name="dest"/>
    <sequential>
      <mkdir dir="@{dest}"/>
      <echo message="installing ivy ${ivy.bootstrap.version} to ${ivy_install_path}"/>
      <get src="@{src}/org/apache/ivy/ivy/${ivy.bootstrap.version}/ivy-${ivy.bootstrap.version}.jar"
           dest="@{dest}/ivy-${ivy.bootstrap.version}.jar" usetimestamp="true" ignoreerrors="true"/>
    </sequential>
  </macrodef>

  <target name="compile-core" depends="init, clover"
          description="Compiles core classes">
    <compile
      srcdir="${src.dir}"
      destdir="${build.dir}/classes/java">
      <classpath refid="classpath"/>
    </compile>

    <!-- Copy the resources folder (if existent) -->
    <copy todir="${build.dir}/classes/java">
      <fileset dir="${resources.dir}" erroronmissingdir="no"/>
    </copy>
  </target>

  <target name="compile" depends="compile-core">
    <!-- convenience target to compile core -->
  </target>

  <target name="jar-core" depends="compile-core">
    <jarify/>
  </target>

  <property name="lucene.tgz.file" location="${common.dir}/dist/lucene-${version}.tgz"/>
  <available file="${lucene.tgz.file}" property="lucene.tgz.exists"/>
  <property name="lucene.tgz.unpack.dir" location="${common.build.dir}/lucene.tgz.unpacked"/>
  <patternset id="patternset.lucene.solr.jars">
    <include name="**/lucene-*.jar"/>
    <include name="**/solr-*.jar"/>
  </patternset>
  <available type="dir" file="${lucene.tgz.unpack.dir}" property="lucene.tgz.unpack.dir.exists"/>
  <target name="-ensure-lucene-tgz-exists" unless="lucene.tgz.exists">
    <ant dir="${common.dir}" target="package-tgz" inheritall="false">
      <propertyset refid="uptodate.and.compiled.properties"/>
    </ant>
  </target>
  <target name="-unpack-lucene-tgz" unless="lucene.tgz.unpack.dir.exists">
    <antcall target="-ensure-lucene-tgz-exists" inheritall="false">
      <propertyset refid="uptodate.and.compiled.properties"/>
    </antcall>
    <mkdir dir="${lucene.tgz.unpack.dir}"/>
    <untar compression="gzip" src="${lucene.tgz.file}" dest="${lucene.tgz.unpack.dir}">
      <patternset refid="patternset.lucene.solr.jars"/>
    </untar>
  </target>
  <property name="dist.jar.dir.prefix" value="${lucene.tgz.unpack.dir}/lucene"/>
  <pathconvert property="dist.jar.dir.suffix">
    <mapper>
      <chainedmapper>
        <globmapper from="${common.dir}*" to="*"/>
        <globmapper from="*build.xml" to="*"/>
      </chainedmapper>
    </mapper>
    <path location="${ant.file}"/>
  </pathconvert>

  <macrodef name="m2-deploy" description="Builds a Maven artifact">
    <element name="artifact-attachments" optional="yes"/>
    <element name="parent-poms" optional="yes"/>
    <element name="credentials" optional="yes"/>
    <attribute name="pom.xml"/>
    <attribute name="jar.file" default="${dist.jar.dir.prefix}-${version}/${dist.jar.dir.suffix}/${final.name}.jar"/>
    <sequential>
      <artifact:install-provider artifactId="wagon-ssh" version="1.0-beta-7"/>
      <parent-poms/>
      <artifact:pom id="maven.project" file="@{pom.xml}"/>
      <artifact:deploy file="@{jar.file}">
        <artifact-attachments/>
        <remoteRepository id="${m2.repository.id}" url="${m2.repository.url}">
          <credentials/>
        </remoteRepository>
        <pom refid="maven.project"/>
      </artifact:deploy>
      <artifact:install file="@{jar.file}">
        <artifact-attachments/>
        <pom refid="maven.project"/>
      </artifact:install>
    </sequential>
  </macrodef>

  <macrodef name="m2-install" description="Installs a Maven artifact into the local repository">
    <element name="parent-poms" optional="yes"/>
    <attribute name="pom.xml"/>
    <attribute name="jar.file" default="${dist.jar.dir.prefix}-${version}/${dist.jar.dir.suffix}/${final.name}.jar"/>
    <sequential>
      <parent-poms/>
      <artifact:pom id="maven.project" file="@{pom.xml}"/>
      <artifact:install file="@{jar.file}">
        <pom refid="maven.project"/>
      </artifact:install>
    </sequential>
  </macrodef>

  <!-- validate maven dependencies -->
  <macrodef name="m2-validate-dependencies">
      <attribute name="pom.xml"/>
      <attribute name="licenseDirectory"/>
      <element name="excludes" optional="true"/>
      <element name="additional-filters" optional="true"/>
    <sequential>
      <artifact:dependencies filesetId="maven.fileset" useScope="test" type="jar">
        <artifact:pom file="@{pom.xml}"/>
        <!-- disable completely, so this has no chance to download any updates from anywhere: -->
        <remoteRepository id="apache.snapshots" url="foobar://disabled/">
          <snapshots enabled="false"/>
          <releases enabled="false"/>
        </remoteRepository>
      </artifact:dependencies>
      <licenses licenseDirectory="@{licenseDirectory}">
        <restrict>
          <fileset refid="maven.fileset"/>
          <rsel:not>
            <excludes/>
          </rsel:not>
        </restrict>
        <licenseMapper>
          <chainedmapper>
            <filtermapper refid="license-mapper-defaults"/>
            <filtermapper>
              <additional-filters/>
            </filtermapper>
          </chainedmapper>
        </licenseMapper>
      </licenses>
    </sequential>
  </macrodef>

  <macrodef name="build-manifest" description="Builds a manifest file">
    <attribute name="title"/>
    <attribute name="implementation.title"/>
    <attribute name="manifest.file" default="${manifest.file}"/>
    <element name="additional-manifest-attributes" optional="true"/>
    <sequential>
      <local name="-checkoutid"/>
      <local name="-giterr"/>
      <local name="checkoutid"/>
      
      <!-- If possible, include the GIT hash into manifest: -->
      <exec dir="." executable="${git.exe}" outputproperty="-checkoutid" errorproperty="-giterr" failifexecutionfails="false">
        <arg value="log"/>
        <arg value="--format=%H"/>
        <arg value="-n"/>
        <arg value="1"/>
      </exec>
      <condition property="checkoutid" value="${-checkoutid}" else="unknown">
        <matches pattern="^[0-9a-z]+$" string="${-checkoutid}" casesensitive="false" multiline="true"/>
      </condition>

      <!-- create manifest: -->
      <manifest file="@{manifest.file}">
        <!--
        http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#JAR%20Manifest
        http://java.sun.com/j2se/1.5.0/docs/guide/versioning/spec/versioning2.html
        http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Package.html
        http://java.sun.com/j2se/1.5.0/docs/api/java/util/jar/package-summary.html
        http://java.sun.com/developer/Books/javaprogramming/JAR/basics/manifest.html
        -->
        <!-- Don't set 'Manifest-Version' it identifies the version of the
             manifest file format, and should always be 1.0 (the default)

             Don't set 'Created-by' attribute, its purpose is
             to identify the version of java used to build the jar,
             which ant will do by default.

             Ant will happily override these with bogus strings if you
             tell it to, so don't.

             NOTE: we don't use section info because all of our manifest data
             applies to the entire jar/war ... no package specific info.
        -->
        <attribute name="Extension-Name" value="@{implementation.title}"/>
        <attribute name="Specification-Title" value="@{title}"/>
        <!-- spec version must match "digit+{.digit+}*" -->
        <attribute name="Specification-Version" value="${spec.version}"/>
        <attribute name="Specification-Vendor"
                   value="The Apache Software Foundation"/>
        <attribute name="Implementation-Title" value="@{implementation.title}"/>
        <!-- impl version can be any string -->
        <attribute name="Implementation-Version"
                   value="${version} ${checkoutid} - ${user.name} - ${DSTAMP} ${TSTAMP}"/>
        <attribute name="Implementation-Vendor"
                   value="The Apache Software Foundation"/>
        <attribute name="X-Compile-Source-JDK" value="${javac.release}"/>
        <attribute name="X-Compile-Target-JDK" value="${javac.release}"/>
        <additional-manifest-attributes />
      </manifest>
    </sequential>
  </macrodef>
  
  <macrodef name="jarify" description="Builds a JAR file">
    <attribute name="basedir" default="${build.dir}/classes/java"/>
    <attribute name="destfile" default="${build.dir}/${final.name}.jar"/>
    <attribute name="title" default="Lucene Search Engine: ${ant.project.name}"/>
    <attribute name="excludes" default="**/pom.xml,**/*.iml"/>
    <attribute name="metainf.source.dir" default="${common.dir}"/>
    <attribute name="implementation.title" default="org.apache.lucene"/>
    <attribute name="manifest.file" default="${manifest.file}"/>
    <element name="filesets" optional="true"/>
    <element name="jarify-additional-manifest-attributes" optional="true"/>
    <sequential>
      <build-manifest title="@{title}"
                      implementation.title="@{implementation.title}"
                      manifest.file="@{manifest.file}">
        <additional-manifest-attributes>
          <jarify-additional-manifest-attributes />
        </additional-manifest-attributes>
      </build-manifest>
      
      <jar destfile="@{destfile}"
           basedir="@{basedir}"
           manifest="@{manifest.file}"
           excludes="@{excludes}">
        <metainf dir="@{metainf.source.dir}" includes="LICENSE.txt,NOTICE.txt"/>
        <filesets />
      </jar>
    </sequential>
  </macrodef>

  <macrodef name="module-uptodate">
    <attribute name="name"/>
    <attribute name="property"/>
    <attribute name="jarfile"/>
    <attribute name="module-src-name" default="@{name}"/>
    <sequential>
      <uptodate property="@{property}" targetfile="@{jarfile}">
        <srcfiles dir="${common.dir}/@{module-src-name}/src/java" includes="**/*.java"/>
      </uptodate>
    </sequential>
  </macrodef>

  <property name="lucene-core.jar" value="${common.dir}/build/core/lucene-core-${version}.jar"/>
  <target name="check-lucene-core-uptodate" unless="lucene-core.uptodate">
    <uptodate property="lucene-core.uptodate" targetfile="${lucene-core.jar}">
       <srcfiles dir="${common.dir}/core/src/java" includes="**/*.java"/>
    </uptodate>
  </target>
  <target name="jar-lucene-core" unless="lucene-core.uptodate" depends="check-lucene-core-uptodate">
    <ant dir="${common.dir}/core" target="jar-core" inheritAll="false">
      <propertyset refid="uptodate.and.compiled.properties"/>
    </ant>
    <property name="lucene-core.uptodate" value="true"/>
  </target>
  
  <target name="compile-lucene-core" unless="core.compiled">
    <ant dir="${common.dir}/core" target="compile-core" inheritAll="false">
      <propertyset refid="uptodate.and.compiled.properties"/>
    </ant>
    <property name="core.compiled" value="true"/>
  </target>

  <target name="check-lucene-core-javadocs-uptodate" unless="core-javadocs.uptodate">
    <uptodate property="core-javadocs.uptodate" targetfile="${common.dir}/build/core/lucene-core-${version}-javadoc.jar">
       <srcfiles dir="${common.dir}/core/src/java" includes="**/*.java"/>
    </uptodate>
  </target>

  <target name="check-lucene-codecs-javadocs-uptodate" unless="codecs-javadocs.uptodate">
    <uptodate property="codecs-javadocs.uptodate" targetfile="${common.dir}/build/codecs/lucene-codecs-${version}-javadoc.jar">
       <srcfiles dir="${common.dir}/codecs/src/java" includes="**/*.java"/>
    </uptodate>
  </target>

  <target name="javadocs-lucene-core" depends="check-lucene-core-javadocs-uptodate" unless="core-javadocs.uptodate">
    <ant dir="${common.dir}/core" target="javadocs" inheritAll="false">
      <propertyset refid="uptodate.and.compiled.properties"/>
    </ant>
    <property name="core-javadocs.uptodate" value="true"/>
  </target>

  <target name="compile-codecs" unless="codecs.compiled">
    <ant dir="${common.dir}/codecs" target="compile-core" inheritAll="false">
      <propertyset refid="uptodate.and.compiled.properties"/>
    </ant>
    <property name="codecs.compiled" value="true"/>
  </target>

  <target name="javadocs-lucene-codecs" depends="check-lucene-codecs-javadocs-uptodate" unless="codecs-javadocs.uptodate">
    <ant dir="${common.dir}/codecs" target="javadocs" inheritAll="false">
      <propertyset refid="uptodate.and.compiled.properties"/>
    </ant>
    <property name="codecs-javadocs.uptodate" value="true"/>
  </target>

  <target name="compile-test-framework" unless="lucene.test.framework.compiled">
    <ant dir="${common.dir}/test-framework" target="compile-core" inheritAll="false">
      <propertyset refid="uptodate.and.compiled.properties"/>
    </ant>
    <property name="lucene.test.framework.compiled" value="true"/>
  </target>

  <target name="check-lucene-test-framework-javadocs-uptodate" 
          unless="lucene.test.framework-javadocs.uptodate">
    <uptodate property="lucene.test.framework-javadocs.uptodate" 
         targetfile="${common.dir}/build/test-framework/lucene-test-framework-${version}-javadoc.jar">
       <srcfiles dir="${common.dir}/test-framework/src/java" includes="**/*.java"/>
    </uptodate>
  </target>

  <target name="javadocs-test-framework" 
          depends="check-lucene-test-framework-javadocs-uptodate"
          unless="lucene.test.framework-javadocs.uptodate">
    <ant dir="${common.dir}/test-framework" target="javadocs" inheritAll="false">
      <propertyset refid="uptodate.and.compiled.properties"/>
    </ant>
    <property name="lucene.test.framework-javadocs.uptodate" value="true"/>
  </target>

  <target name="compile-tools">
    <ant dir="${common.dir}/tools" target="compile-core" inheritAll="false"/>
  </target>

  <target name="compile-test" depends="compile-core,compile-test-framework">
    <compile-test-macro srcdir="${tests.src.dir}" destdir="${build.dir}/classes/test" test.classpath="test.classpath"/>
  </target>

  <macrodef name="compile-test-macro" description="Compiles junit tests.">
    <attribute name="srcdir"/>
    <attribute name="destdir"/>
    <attribute name="test.classpath"/>
    <attribute name="javac.release" default="${javac.release}"/>
    <sequential>
      <compile
        srcdir="@{srcdir}" 
        destdir="@{destdir}"
        javac.release="@{javac.release}">
        <classpath refid="@{test.classpath}"/>
      </compile>

      <!-- Copy any data files present to the classpath -->
      <copy todir="@{destdir}">
        <fileset dir="@{srcdir}" excludes="**/*.java"/>
      </copy>
    </sequential>
  </macrodef>

  <target name="test-updatecache" description="Overwrite tests' timings cache for balancing." depends="install-junit4-taskdef">
    <touch file="${tests.cachefile}" mkdirs="true" verbose="false" />
    <junit4:mergehints file="${tests.cachefile}" historyLength="${tests.cachefilehistory}">
      <resources>
        <!-- The order is important. Include previous stats first, then append new stats. -->
        <file file="${tests.cachefile}" />
        <fileset dir="${tests.cachedir}">
          <include name="**/*.txt" />
        </fileset>
      </resources>
    </junit4:mergehints>
  </target>

  <!-- Aliases for tests filters -->
  <condition property="tests.class" value="*.${testcase}">
    <isset property="testcase" />
  </condition>
  <condition property="tests.method" value="${testmethod}*">
    <isset property="testmethod" />
  </condition>

  <condition property="tests.showSuccess" value="true" else="false">
    <or>
      <isset property="tests.class" />
      <isset property="tests.method" />
    </or>
  </condition>

  <condition property="tests.showOutput" value="always" else="onerror">
    <or>
      <isset property="tests.class" />
      <isset property="tests.method" />
      <istrue value="${tests.showSuccess}"/>
    </or>
  </condition>

  <!-- Test macro using junit4. -->
  <macrodef name="test-macro" description="Executes junit tests.">
    <attribute name="junit.output.dir" default="${junit.output.dir}"/>
    <attribute name="junit.classpath" default="junit.classpath"/>
    <attribute name="testsDir" default="${build.dir}/classes/test"/>
    <attribute name="workDir" default="${tests.workDir}"/>
    <attribute name="threadNum" default="1"/>
    <attribute name="tests.nightly" default="${tests.nightly}"/>
    <attribute name="tests.weekly" default="${tests.weekly}"/>
    <attribute name="tests.monster" default="${tests.monster}"/>
    <attribute name="tests.slow" default="${tests.slow}"/>
    <attribute name="tests.multiplier" default="${tests.multiplier}"/>
    <attribute name="additional.vm.args" default=""/>
    <!-- note this enables keeping junit4 files only (not test temp files) -->
    <attribute name="runner.leaveTemporary" default="false"/>
      
    <sequential>
        <!-- Warn if somebody uses removed properties. -->
        <fail message="This property has been removed: tests.iter, use -Dtests.iters=N.">
          <condition>
            <isset property="tests.iter" />
          </condition>
        </fail>
        <!-- this combo makes no sense LUCENE-4146 -->
        <fail message="You are attempting to use 'tests.iters' in combination with a 'tests.method' value with does not end in a '*' -- This combination makes no sense, because the 'tests.method' filter will be unable to match the synthetic test names generated by the multiple iterations.">
          <condition>
            <and>
              <isset property="tests.iters" />
              <isset property="tests.method" />
              <not>
                <matches pattern="\*$" string="${tests.method}" />
              </not>
            </and>
          </condition>
        </fail>

        <!-- Defaults. -->
        <property name="tests.class"  value="" />
        <property name="tests.method" value="" />
        <property name="tests.dynamicAssignmentRatio" value="0.50" /> <!-- 50% of suites -->
        <property name="tests.haltonfailure" value="true" />
        <property name="tests.leaveTemporary" value="false" />
        <!-- 
           keep junit4 runner files or not (independent of keeping test output files)
         -->
        <condition property="junit4.leaveTemporary">
          <or>
            <istrue value="${tests.leaveTemporary}"/> 
            <istrue value="@{runner.leaveTemporary}"/> 
          </or>
        </condition>
        <property name="tests.iters" value="" />
        <property name="tests.dups"  value="1" />
        <property name="tests.useSecurityManager"  value="true" />

        <property name="tests.heapdump.args" value=""/>

        <!-- turn on security manager? -->
        <condition property="java.security.manager" value="org.apache.lucene.util.TestSecurityManager">
          <istrue value="${tests.useSecurityManager}"/>
        </condition>

        <!-- create a fileset pattern that matches ${tests.class}. -->
        <loadresource property="tests.explicitclass" quiet="true">
          <propertyresource name="tests.class" />
          <filterchain>
            <tokenfilter>
              <filetokenizer/>
              <replacestring from="." to="/"/>
              <replacestring from="*" to="**"/>
              <replaceregex pattern="$" replace=".class" />
            </tokenfilter>
          </filterchain>
        </loadresource>

        <!-- Pick the random seed now (unless already set). -->
        <junit4:pickseed property="tests.seed" />

        <!-- Pick file.encoding based on the random seed. -->
        <junit4:pickfromlist property="tests.file.encoding" allowundefined="false" seed="${tests.seed}">
            <!-- Guaranteed support on any JVM. -->
            <value>US-ASCII</value>   <!-- single byte length -->
            <value>ISO-8859-1</value> <!-- single byte length -->
            <value>UTF-8</value>      <!-- variable byte length -->
            <value><!-- empty/ default encoding. --></value>

            <!--
            Disabled because of Java 1.8 bug on Linux/ Unix:
            http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7181721

            <value>UTF-16</value>     
            <value>UTF-16LE</value>   
            <value>UTF-16BE</value>
            -->
        </junit4:pickfromlist>

        <!-- junit4 does not create this directory. TODO: is this a bug / inconsistency with dir="..."? -->
        <mkdir dir="@{workDir}/temp" />

        <!-- Local test execution statistics from defaults or local caches, if present. -->
        <local name="tests.caches" />
        <available file="${tests.cachedir}/${name}" type="dir" property="tests.caches" value="${tests.cachedir}/${name}" />
        <property name="tests.caches" location="${common.dir}/tools/junit4" /> <!-- defaults -->
        <mkdir dir="${tests.cachedir}/${name}" />

        <local name="junit4.stats.nonIgnored" />

        <junit4:junit4
            taskName="junit4"
            dir="@{workDir}"
            tempdir="@{workDir}/temp"
            maxmemory="${tests.heapsize}"

            statsPropertyPrefix="junit4.stats"

            parallelism="@{threadNum}"

            printSummary="true"
            haltonfailure="${tests.haltonfailure}" 
            failureProperty="tests.failed"

            dynamicAssignmentRatio="${tests.dynamicAssignmentRatio}"
            shuffleOnSlave="true"
            leaveTemporary="${junit4.leaveTemporary}"
            seed="${tests.seed}"
            onNonEmptyWorkDirectory="wipe"

            heartbeat="${tests.heartbeat}"
            uniqueSuiteNames="false"
            
            debugstream="false"
        >
            <!-- Classpaths. -->
            <classpath refid="@{junit.classpath}"/>
            <classpath refid="clover.classpath" />

            <!-- JVM arguments and system properties. -->
            <jvmarg line="${args}"/>
            <jvmarg line="${tests.heapdump.args}"/>
            <jvmarg line="${tests.clover.args}"/>
            <jvmarg line="@{additional.vm.args}"/>
            <jvmarg line="${tests.asserts.args}"/>

            <!-- set the number of times tests should run -->
            <sysproperty key="tests.iters" value="${tests.iters}"/>
            <!-- allow tests to control debug prints -->
            <sysproperty key="tests.verbose" value="${tests.verbose}"/>
            <!-- even more debugging -->
            <sysproperty key="tests.infostream" value="${tests.infostream}"/>
            <!-- set the codec tests should run with -->
            <sysproperty key="tests.codec" value="${tests.codec}"/>
            <!-- set the postingsformat tests should run with -->
            <sysproperty key="tests.postingsformat" value="${tests.postingsformat}"/>
            <!-- set the docvaluesformat tests should run with -->
            <sysproperty key="tests.docvaluesformat" value="${tests.docvaluesformat}"/>
            <!-- set the locale tests should run with -->
            <sysproperty key="tests.locale" value="${tests.locale}"/>
            <!-- set the timezone tests should run with -->
            <sysproperty key="tests.timezone" value="${tests.timezone}"/>
            <!-- set the directory tests should run with -->
            <sysproperty key="tests.directory" value="${tests.directory}"/>
            <!-- set the line file source for oal.util.LineFileDocs -->
            <sysproperty key="tests.linedocsfile" value="${tests.linedocsfile}"/>
            <!-- set the Version that tests should run against -->
            <sysproperty key="tests.luceneMatchVersion" value="${tests.luceneMatchVersion}"/>
            <!-- for lucene we can be strict, and we don't want false fails even across methods -->
            <sysproperty key="tests.cleanthreads" value="${tests.cleanthreads.sysprop}"/>
            <!-- logging config file -->
            <sysproperty key="java.util.logging.config.file" value="${tests.loggingfile}"/>
            <!-- set whether or not nightly tests should run -->
            <sysproperty key="tests.nightly" value="@{tests.nightly}"/>
              <!-- set whether or not weekly tests should run -->
            <sysproperty key="tests.weekly" value="@{tests.weekly}"/>
            <!-- set whether or not monster tests should run -->
            <sysproperty key="tests.monster" value="@{tests.monster}"/>
              <!-- set whether or not slow tests should run -->
            <sysproperty key="tests.slow" value="@{tests.slow}"/>
              
            <!-- set whether tests framework should not require java assertions enabled -->
            <sysproperty key="tests.asserts" value="${tests.asserts}"/>

            <!-- TODO: create propertyset for test properties, so each project can have its own set -->
            <sysproperty key="tests.multiplier" value="@{tests.multiplier}"/>
            
            <!-- Temporary directory a subdir of the cwd. -->
            <sysproperty key="tempDir" value="./temp" />
            <sysproperty key="java.io.tmpdir" value="./temp" />

            <!-- Restrict access to certain Java features and install security manager: -->
            <sysproperty key="junit4.tempDir" file="@{workDir}/temp" />
            <sysproperty key="common.dir" file="${common.dir}" />
            <sysproperty key="clover.db.dir" file="${clover.db.dir}" />
            <syspropertyset>
                <propertyref prefix="java.security.manager"/>
            </syspropertyset>
            <sysproperty key="java.security.policy" file="${tests.policy}" />

            <sysproperty key="tests.LUCENE_VERSION" value="${version.base}"/>

            <sysproperty key="jetty.testMode" value="1"/>
            <sysproperty key="jetty.insecurerandom" value="1"/>
            <sysproperty key="solr.directoryFactory" value="org.apache.solr.core.MockDirectoryFactory"/>
            
            <!-- disable AWT while running tests -->
            <sysproperty key="java.awt.headless" value="true"/>

            <!-- turn jenkins blood red for hashmap bugs, even on jdk7 -->
            <sysproperty key="jdk.map.althashing.threshold" value="0"/>

            <sysproperty key="tests.src.home" value="${user.dir}" />

            <!-- replaces default random source to the nonblocking variant -->
            <sysproperty key="java.security.egd" value="file:/dev/./urandom"/>

            <!-- Only pass these to the test JVMs if defined in ANT. -->
            <syspropertyset>
                <propertyref prefix="tests.maxfailures" />
                <propertyref prefix="tests.failfast" />
                <propertyref prefix="tests.badapples" />
                <propertyref prefix="tests.bwcdir" />
                <propertyref prefix="tests.timeoutSuite" />
                <propertyref prefix="tests.disableHdfs" />
                <propertyref prefix="tests.filter" />
                <propertyref prefix="tests.awaitsfix" />
                <propertyref prefix="tests.leavetmpdir" />
                <propertyref prefix="tests.leaveTemporary" />
                <propertyref prefix="tests.leavetemporary" />
                <propertyref prefix="solr.test.leavetmpdir" />
                <propertyref prefix="solr.tests.use.numeric.points" />
            </syspropertyset>

            <!-- Pass randomized settings to the forked JVM. -->
            <syspropertyset ignoreEmpty="true">
                <propertyref prefix="tests.file.encoding" />
                <mapper type="glob" from="tests.*" to="*" />
            </syspropertyset>

            <!-- Use static cached test balancing statistics. -->
            <balancers>
                <junit4:execution-times>
                    <fileset dir="${tests.caches}"  includes="**/*.txt" />
                </junit4:execution-times>
            </balancers>            

            <!-- Reporting listeners. -->
            <listeners>
                <!-- A simplified console output (maven-like). -->
                <junit4:report-text
                    showThrowable="true" 
                    showStackTraces="true" 
                    showOutput="${tests.showOutput}" 

                    showStatusOk="${tests.showSuccess}"
                    showStatusError="${tests.showError}"
                    showStatusFailure="${tests.showFailure}"
                    showStatusIgnored="${tests.showIgnored}"

                    showSuiteSummary="${tests.showSuiteSummary}"

                    useSimpleNames="${tests.useSimpleNames}"
                    maxClassNameColumns="${tests.maxClassNameColumns}"
                    
                    timestamps="${tests.timestamps}"
                    showNumFailures="${tests.showNumFailures}">

                  <!-- Filter stack traces. The default set of filters is similar to Ant's (reflection, assertions, junit's own stuff). -->
                  <junit4:filtertrace defaults="true" enabled="${tests.filterstacks}">
                    <!-- Lucene-specific stack frames (test rules mostly). -->
                    <containsstring contains="at com.carrotsearch.randomizedtesting.RandomizedRunner" />
                    <containsstring contains="at org.apache.lucene.util.AbstractBeforeAfterRule" />
                    <containsstring contains="at com.carrotsearch.randomizedtesting.rules." />
                    <containsstring contains="at org.apache.lucene.util.TestRule" />
                    <containsstring contains="at com.carrotsearch.randomizedtesting.rules.StatementAdapter" />
                    <containsstring contains="at com.carrotsearch.randomizedtesting.ThreadLeakControl" />

                    <!-- Add custom filters if you like. Lines that match these will be removed. -->
                    <!--
                    <containsstring contains=".." /> 
                    <containsregex pattern="^(\s+at )(org\.junit\.)" /> 
                    -->
                  </junit4:filtertrace>                    
                </junit4:report-text>

                <!-- Emits full status for all tests, their relative order on forked JVMs. -->
                <junit4:report-text
                    file="@{junit.output.dir}/tests-report.txt"
                    showThrowable="true" 
                    showStackTraces="true" 
                    showOutput="always"

                    showStatusOk="true"
                    showStatusError="true"
                    showStatusFailure="true"
                    showStatusIgnored="true"

                    showSuiteSummary="true"
                    timestamps="true"
                />

                <!-- Emits status on errors and failures only. -->
                <junit4:report-text
                    file="@{junit.output.dir}/tests-failures.txt"
                    showThrowable="true" 
                    showStackTraces="true" 
                    showOutput="onerror" 

                    showStatusOk="false"
                    showStatusError="true"
                    showStatusFailure="true"
                    showStatusIgnored="false"

                    showSuiteSummary="false"
                    timestamps="true"
                />
                
                <!-- Emit the information about tests timings (could be used to determine
                     the slowest tests or for reuse in balancing). -->
                <junit4:report-execution-times file="${tests.cachedir}/${name}/timehints.txt" historyLength="20" />

                <!-- ANT-compatible XMLs for jenkins records etc. -->
                <junit4:report-ant-xml dir="@{junit.output.dir}" outputStreams="no" />

                <!--
                Enable if you wish to have a nice HTML5 report.
                <junit4:report-json file="@{junit.output.dir}/tests-report-${ant.project.name}/index.html" outputStreams="no" />
                -->
            </listeners>

            <!-- Input test classes. -->
            <junit4:duplicate times="${tests.dups}">
              <fileset dir="@{testsDir}">
                <include name="**/Test*.class" />
                <include name="**/*Test.class" />
                <include name="${tests.explicitclass}" if="tests.explicitclass" />
                <exclude name="**/*$*" />
              </fileset>
            </junit4:duplicate>
        </junit4:junit4>

        <!-- Append the number of non-ignored (actually executed) tests. -->
        <echo file="${tests.totals.tmpfile}" append="true" encoding="UTF-8"># module: ${ant.project.name}&#x000a;${junit4.stats.nonIgnored}&#x000a;</echo>
        
        <fail message="Beasting executed no tests (a typo in the filter pattern maybe?)">
          <condition>
            <and>
              <isset property="tests.isbeasting"/>
              <equals arg1="${junit4.stats.nonIgnored}" arg2="0"/>
            </and>
          </condition>
        </fail>

        <!-- Report the 5 slowest tests from this run to the console. -->
        <echo level="info">5 slowest tests:</echo>
        <junit4:tophints max="5">
          <file file="${tests.cachedir}/${name}/timehints.txt" />
        </junit4:tophints>
    </sequential>
  </macrodef>

  <target name="test-times" description="Show the slowest tests (averages)." depends="install-junit4-taskdef">
    <property name="max" value="10" />
    <echo>Showing ${max} slowest tests according to local stats. (change with -Dmax=...).</echo>
    <junit4:tophints max="${max}">
      <fileset dir="${tests.cachedir}" includes="**/*.txt" />
    </junit4:tophints>

    <echo>Showing ${max} slowest tests in cached stats. (change with -Dmax=...).</echo>
    <junit4:tophints max="${max}">
        <fileset dir="${common.dir}/tools/junit4">
          <include name="*.txt" />
        </fileset>
    </junit4:tophints>
  </target>

  <target name="test-help" description="Help on 'ant test' syntax.">
      <echo taskname="help">
#
# Test case filtering. --------------------------------------------
#
# - 'tests.class' is a class-filtering shell-like glob pattern,
#   'testcase' is an alias of "tests.class=*.${testcase}"
# - 'tests.method' is a method-filtering glob pattern.
#   'testmethod' is an alias of "tests.method=${testmethod}*"
#

# Run a single test case (variants)
ant test -Dtests.class=org.apache.lucene.package.ClassName
ant test "-Dtests.class=*.ClassName"
ant test -Dtestcase=ClassName

# Run all tests in a package and sub-packages
ant test "-Dtests.class=org.apache.lucene.package.*"

# Run any test methods that contain 'esi' (like: ...r*esi*ze...).
ant test "-Dtests.method=*esi*"

#
# Seed and repetitions. -------------------------------------------
#

# Run with a given seed (seed is a hex-encoded long).
ant test -Dtests.seed=DEADBEEF

# Repeats _all_ tests of ClassName N times. Every test repetition
# will have a different seed.
ant test -Dtests.iters=N -Dtestcase=ClassName

# Repeats _all_ tests of ClassName N times. Every test repetition
# will have exactly the same master (dead) and method-level (beef)
# seed.
ant test -Dtests.iters=N -Dtestcase=ClassName -Dtests.seed=dead:beef

# Repeats a given test N times (note the filters - individual test
# repetitions are given suffixes, ie: testFoo[0], testFoo[1], etc...
# so using testmethod or tests.method ending in a glob is necessary
# to ensure iterations are run).
ant test -Dtests.iters=N -Dtestcase=ClassName -Dtestmethod=mytest
ant test -Dtests.iters=N -Dtestcase=ClassName -Dtests.method=mytest*

# Repeats N times but skips any tests after the first failure or M
# initial failures.
ant test -Dtests.iters=N -Dtests.failfast=yes -Dtestcase=...
ant test -Dtests.iters=N -Dtests.maxfailures=M -Dtestcase=...

# Repeats every suite (class) and any tests inside N times
# can be combined with -Dtestcase or -Dtests.iters, etc.
# Can be used for running a single class on multiple JVMs
# in parallel.
ant test -Dtests.dups=N ...

# Test beasting: Repeats every suite with same seed per class
# (N times in parallel) and each test inside (M times). The whole
# run is repeated (beasting) P times in a loop, with a different
# master seed. You can combine beasting with any other parameter,
# just replace "test" with "beast" and give -Dbeast.iters=P
# (P >> 1).
ant beast -Dtests.dups=N -Dtests.iters=M -Dbeast.iters=P \
  -Dtestcase=ClassName

#
# Test groups. ----------------------------------------------------
#
# test groups can be enabled or disabled (true/false). Default
# value provided below in [brackets].

ant -Dtests.nightly=[false]   - nightly test group (@Nightly)
ant -Dtests.weekly=[false]    - weekly tests (@Weekly)
ant -Dtests.awaitsfix=[false] - known issue (@AwaitsFix)
ant -Dtests.slow=[true]       - slow tests (@Slow)

# An alternative way to select just one (or more) groups of tests
# is to use the -Dtests.filter property:

-Dtests.filter="@slow"

# would run only slow tests. 'tests.filter' supports Boolean operators
# 'and, or, not' and grouping, for example:

ant -Dtests.filter="@nightly and not(@awaitsfix or @slow)"

# would run nightly tests but not those also marked as awaiting a fix
# or slow. Note that tests.filter, if present, has a priority over any
# individual tests.* properties.


#
# Load balancing and caches. --------------------------------------
#

# Run sequentially (one slave JVM).
ant -Dtests.jvms=1 test

# Run with more slave JVMs than the default.
# Don't count hypercores for CPU-intense tests.
# Make sure there is enough RAM to handle child JVMs.
ant -Dtests.jvms=8 test

# Use repeatable suite order on slave JVMs (disables job stealing).
ant -Dtests.dynamicAssignmentRatio=0 test

# Update global (versioned!) execution times cache (top level).
ant clean test
ant -f lucene/build.xml test-updatecache

#
# Miscellaneous. --------------------------------------------------
#

# Only run test(s), non-recursively. Faster than "ant test".
# WARNING: Skips jar download and compilation. Clover not supported.
ant test-nocompile
ant -Dtestcase=... test-nocompile

# Run all tests without stopping on errors (inspect log files!).
ant -Dtests.haltonfailure=false test

# Run more verbose output (slave JVM parameters, etc.).
ant -verbose test

# Include additional information like what is printed to 
# sysout/syserr, even if the test passes.
# Enabled automatically when running for a single test case.
ant -Dtests.showSuccess=true test

# Change the default suite timeout to 5 seconds.
ant -Dtests.timeoutSuite=5000! ...

# Display local averaged stats, if any (30 slowest tests).
ant test-times -Dmax=30

# Display a timestamp alongside each suite/ test.
ant -Dtests.timestamps=on ...

# Override forked JVM file.encoding
ant -Dtests.file.encoding=XXX ...

# Don't remove any temporary files under slave directories, even if
# the test passes (any of the following props):
ant -Dtests.leaveTemporary=true
ant -Dtests.leavetmpdir=true
ant -Dsolr.test.leavetmpdir=true

# Do *not* filter stack traces emitted to the console.
ant -Dtests.filterstacks=false

# Skip checking for no-executed tests in modules
ant -Dtests.ifNoTests=ignore ...

# Output test files and reports.
${tests-output}/tests-report.txt    - full ASCII tests report
${tests-output}/tests-failures.txt  - failures only (if any)
${tests-output}/tests-report-*      - HTML5 report with results
${tests-output}/junit4-*.suites     - per-JVM executed suites
                                      (important if job stealing).
      </echo>
  </target>

  <target name="install-junit4-taskdef" depends="ivy-configure">
    <!-- JUnit4 taskdef. -->
    <ivy:cachepath organisation="com.carrotsearch.randomizedtesting" module="junit4-ant" revision="${/com.carrotsearch.randomizedtesting/junit4-ant}"
                   type="jar" inline="true" log="download-only" pathid="path.junit4" />

    <taskdef uri="antlib:com.carrotsearch.junit4">
      <classpath refid="path.junit4" />
    </taskdef>
  </target>

  <target name="test" depends="clover,compile-test,install-junit4-taskdef,validate,-init-totals,-test,-check-totals" description="Runs unit tests"/>
  <target name="beast" depends="clover,compile-test,install-junit4-taskdef,validate,-init-totals,-beast,-check-totals" description="Runs unit tests in a loop (-Dbeast.iters=n)"/>

  <target name="test-nocompile" depends="-clover.disable,install-junit4-taskdef,-init-totals,-test,-check-totals"
          description="Only runs unit tests.  Jars are not downloaded; compilation is not updated; and Clover is not enabled."/>

  <target name="-jacoco-install">
    <!-- download jacoco from ivy if needed -->
    <ivy:cachepath organisation="org.jacoco" module="org.jacoco.ant" type="jar" inline="true" revision="0.7.4.201502262128"
                   log="download-only" pathid="jacoco.classpath" />

    <!-- install jacoco ant tasks -->
    <taskdef uri="antlib:org.jacoco.ant" resource="org/jacoco/ant/antlib.xml">
        <classpath refid="jacoco.classpath"/>
    </taskdef>
  </target>

  <target name="-jacoco-test" depends="clover,compile-test,install-junit4-taskdef,validate,-init-totals">
    <!-- hack: ant task computes absolute path, but we need a relative path, so its per-testrunner -->
    <jacoco:agent property="agentvmparam.raw"/>
    <property name="agentvmparam" value="${agentvmparam.raw}destfile=jacoco.db,append=false"/>
  
    <!-- create output dir if needed -->
    <mkdir dir="${junit.output.dir}"/>

    <!-- run tests, with agent vm args, and keep runner files around -->
    <test-macro threadNum="${tests.jvms.override}" additional.vm.args="${agentvmparam}" runner.leaveTemporary="true"/>
  </target>

  <target name="-jacoco-report" depends="-check-totals">
    <property name="jacoco.output.dir" location="${jacoco.report.dir}/${name}"/>
    <!-- try to clean output dir to prevent any confusion -->
    <delete dir="${jacoco.output.dir}" failonerror="false"/>
    <mkdir dir="${jacoco.output.dir}"/>

    <!-- print jacoco reports -->
    <jacoco:report>
      <executiondata>
        <fileset dir="${junit.output.dir}" includes="**/jacoco.db"/>
      </executiondata>
      <structure name="${final.name} JaCoCo coverage report">
        <classfiles>
          <fileset dir="${build.dir}/classes/java"/>
        </classfiles>
        <sourcefiles>
          <fileset dir="${src.dir}"/>
        </sourcefiles>
      </structure>
      <html destdir="${jacoco.output.dir}" footer="Copyright ${year} Apache Software Foundation.  All Rights Reserved."/>
    </jacoco:report>
  </target>

  <target name="jacoco" depends="-jacoco-install,-jacoco-test,-jacoco-report" description="Generates JaCoCo coverage report"/>

  <!-- Run the actual tests (must be wrapped with -init-totals, -check-totals) -->
  <target name="-test">
    <mkdir dir="${junit.output.dir}"/>
    <test-macro threadNum="${tests.jvms.override}" />
  </target>

  <!-- Beast the actual tests (must be wrapped with -init-totals, -check-totals) -->
  <target name="-beast" depends="resolve-groovy">
    <fail message="The Beast only works inside of individual modules (where 'junit.classpath' is defined)">
      <condition>
        <not><isreference refid="junit.classpath"/></not>
      </condition>
    </fail>
    <groovy taskname="beaster"><![CDATA[
      import org.apache.tools.ant.BuildException;
      import org.apache.tools.ant.BuildLogger;
      import org.apache.tools.ant.Project;
      
      int iters = (properties['beast.iters'] ?: '1') as int;
      if (iters <= 1) {
        throw new BuildException("Please give -Dbeast.iters with an int value > 1.");
      }
      
      def antcall = project.createTask('antcall');
      antcall.with {
        target = '-test';
        inheritAll = true;
        inheritRefs = true;
        createParam().with {
          name = "tests.isbeasting";
          value = "true";
        };
      };
      
      (1..iters).each { i ->
        task.log('Beast round: ' + i, Project.MSG_INFO);
        try {
          // disable verbose build logging:
          project.buildListeners.each { listener ->
            if (listener instanceof BuildLogger) {
              listener.messageOutputLevel = Project.MSG_WARN;
            }
          };
          
          antcall.execute();
          
        } catch (BuildException be) {
          def logFile = new File(properties["junit.output.dir"], "tests-failures.txt");
          if (logFile.exists()) {
            logFile.eachLine("UTF-8", { line ->
              task.log(line, Project.MSG_ERR);
            });
          }
          throw be;
        } finally {
          // restore build logging (unfortunately there is no way to get the original logging level (write-only property):
          project.buildListeners.each { listener ->
            if (listener instanceof BuildLogger) {
              listener.messageOutputLevel = Project.MSG_INFO;
            }
          };
        }
      };
      task.log('Beasting finished.', Project.MSG_INFO);
    ]]></groovy>
  </target>

  <target name="-check-totals" if="tests.totals.toplevel" depends="resolve-groovy">
    <!-- We are concluding a test pass at the outermost level. Sum up all executed tests. -->
    <groovy><![CDATA[
      import org.apache.tools.ant.BuildException;
      
      total = 0;
      statsFile = new File(properties["tests.totals.tmpfile"]);
      statsFile.eachLine("UTF-8", { line ->
        if (line ==~ /^[0-9]+/) {
          total += Integer.valueOf(line);
        }
      });
      statsFile.delete();

      if (total == 0 && !"ignore".equals(project.getProperty("tests.ifNoTests"))) {
        throw new BuildException("Not even a single test was executed (a typo in the filter pattern maybe?).");
      }

      // Interesting but let's keep the build output quiet.
      // task.log("Grand total of all executed tests (including sub-modules): " + total);
    ]]></groovy>
  </target>

  <!-- The groovy dependency is wanted: this is done early before any test or any other submodule is ran, to prevent permgen errors! -->
  <target name="-init-totals" unless="tests.totals.tmpfile" depends="resolve-groovy">
    <mkdir dir="${build.dir}" />
    <tempfile property="tests.totals.tmpfile"
              destdir="${build.dir}"
              prefix=".test-totals-"
              suffix=".tmp"
              deleteonexit="true"
              createfile="true" />
    <property name="tests.totals.toplevel" value="true" />
  </target>

  <!--
   See http://issues.apache.org/jira/browse/LUCENE-721
   -->
  <target name="clover" depends="-clover.disable,-clover.load,-clover.classpath,-clover.setup"/>
  
  <target name="-clover.load" depends="ivy-availability-check,ivy-configure" if="run.clover" unless="clover.loaded">
    <available file="${clover.license.path}" property="clover.license.available" />
    <fail unless="clover.license.available"><![CDATA[.

  #########################################################################
  Atlassian Clover License not found!
  
  Current License path: ${clover.license.path}

  To use Atlassian Clover with Lucene build, you need a proper license
  and let the system property 'clover.license.path' point to it.
  You can pass it to ANT with:
  
  $ ant -Dclover.license.path=/path/to/clover.license -Drun.clover=true ...
  
  Apache Lucene/Solr source checkouts from Git already contain the
  file, but source distributions cannot because of legal reasons.
  #########################################################################
  
]]></fail>
    <echo>Code coverage with Atlassian Clover enabled.</echo>
    <ivy:cachepath organisation="com.atlassian.clover" module="clover" revision="4.0.4"
      inline="true" conf="master" pathid="clover.classpath"/>
    <taskdef resource="cloverlib.xml" classpathref="clover.classpath" />
    <mkdir dir="${clover.db.dir}"/>
    <!-- This is a hack, instead of setting "clover.loaded" to "true", we set it
     to the stringified classpath. So it can be passed down to subants,
     and reloaded by "-clover.classpath" task (see below): -->
    <pathconvert property="clover.loaded" refid="clover.classpath"/>
  </target>
  
  <target name="-clover.classpath" if="run.clover">
    <!-- redefine the clover classpath refid for tests by using the hack above: -->
    <path id="clover.classpath" path="${clover.loaded}"/>
  </target>

  <target name="-clover.setup" if="run.clover">
    <clover-setup initString="${clover.db.dir}/coverage.db" encoding="${build.encoding}">
      <fileset dir="${src.dir}" erroronmissingdir="no">
        <include name="org/apache/**/*.java" />
      </fileset>
      <testsources dir="${tests.src.dir}" erroronmissingdir="no">
        <include name="org/apache/**/*.java" />
      </testsources>
    </clover-setup>
  </target>

  <target name="-clover.disable" unless="run.clover">
    <!-- define dummy clover path used by junit -->
    <path id="clover.classpath"/>
  </target>

  <target name="pitest" if="run.pitest" depends="compile-test,install-junit4-taskdef,clover,validate"
      description="Run Unit tests using pitest mutation testing. To use, specify -Drun.pitest=true on the command line.">
    <echo>Code coverage with pitest enabled.</echo>
    <ivy:cachepath
        organisation="org.pitest" module="pitest-ant"
        inline="true"
        pathid="pitest.framework.classpath" />
    <pitest-macro />
  </target>

  <target name="generate-test-reports" description="Generates test reports">
    <mkdir dir="${junit.reports}"/>
    <junitreport todir="${junit.output.dir}">
      <!-- this fileset let's the task work for individual modules,
           as well as the project as a whole
       -->
      <fileset dir="${build.dir}">
        <include name="**/test/TEST-*.xml"/>
      </fileset>
      <report format="frames" todir="${junit.reports}"/>
    </junitreport>
  </target>

  <target name="jar" depends="jar-core">
    <!-- convenience target to package core JAR -->
  </target>

  <target name="jar-src">
    <sequential>
      <mkdir dir="${build.dir}" />
      <jarify basedir="${src.dir}" destfile="${build.dir}/${final.name}-src.jar">
        <filesets>
          <fileset dir="${resources.dir}" erroronmissingdir="no"/>
        </filesets>
      </jarify>
    </sequential>
  </target>

  <target name="default" depends="jar-core"/>

  <available type="file" file="pom.xml" property="pom.xml.present"/>

  <!-- TODO, this is really unintuitive how we depend on a target that does not exist -->
  <target name="javadocs">
    <fail message="You must redefine the javadocs task to do something!!!!!"/>
  </target>

  <target name="install-maven-tasks" unless="maven-tasks.uptodate" depends="ivy-availability-check,ivy-configure">
    <property name="maven-tasks.uptodate" value="true"/>
    <ivy:cachepath organisation="org.apache.maven" module="maven-ant-tasks" revision="2.1.3"
             inline="true" conf="master" type="jar" pathid="maven-ant-tasks.classpath"/>
    <taskdef resource="org/apache/maven/artifact/ant/antlib.xml" 
             uri="antlib:org.apache.maven.artifact.ant" 
             classpathref="maven-ant-tasks.classpath"/>
  </target>

  <target name="-dist-maven" depends="install-maven-tasks, jar-src, javadocs">
    <sequential>
      <property name="top.level.dir" location="${common.dir}/.."/>
      <pathconvert property="pom.xml">
        <mapper>
          <chainedmapper>
            <globmapper from="${top.level.dir}*" to="${filtered.pom.templates.dir}*"/>
            <globmapper from="*build.xml" to="*pom.xml"/>
          </chainedmapper>
        </mapper>
        <path location="${ant.file}"/>
      </pathconvert>
      <m2-deploy pom.xml="${pom.xml}">
        <artifact-attachments>
          <attach file="${build.dir}/${final.name}-src.jar"
                  classifier="sources"/>
          <attach file="${build.dir}/${final.name}-javadoc.jar"
                  classifier="javadoc"/>
        </artifact-attachments>
      </m2-deploy>
    </sequential>
  </target>

  <target name="-install-to-maven-local-repo" depends="install-maven-tasks">
    <sequential>
      <property name="top.level.dir" location="${common.dir}/.."/>
      <pathconvert property="pom.xml">
        <mapper>
          <chainedmapper>
            <globmapper from="${top.level.dir}*" to="${filtered.pom.templates.dir}*"/>
            <globmapper from="*build.xml" to="*pom.xml"/>
          </chainedmapper>
        </mapper>
        <path location="${ant.file}"/>
      </pathconvert>
      <artifact:pom id="maven.project" file="${pom.xml}"/>
      <artifact:install file="${dist.jar.dir.prefix}-${version}/${dist.jar.dir.suffix}/${final.name}.jar">
        <pom refid="maven.project"/>
      </artifact:install>
    </sequential>
  </target>

  <target name="-install-src-java-to-maven-local-repo" depends="install-maven-tasks">
    <sequential>
      <property name="top.level.dir" location="${common.dir}/.."/>
      <pathconvert property="pom.xml">
        <mapper>
          <chainedmapper>
            <globmapper from="${top.level.dir}*" to="${filtered.pom.templates.dir}*"/>
            <globmapper from="*build.xml" to="*/src/java/pom.xml"/>
          </chainedmapper>
        </mapper>
        <path location="${ant.file}"/>
      </pathconvert>
      <artifact:pom id="maven.project" file="${pom.xml}"/>
      <artifact:install file="${dist.jar.dir.prefix}-${version}/${dist.jar.dir.suffix}/${final.name}.jar">
        <pom refid="maven.project"/>
      </artifact:install>
    </sequential>
  </target>

  <target name="-dist-maven-src-java" depends="install-maven-tasks, jar-src, javadocs">
    <sequential>
      <property name="top.level.dir" location="${common.dir}/.."/>
      <pathconvert property="pom.xml">
        <mapper>
          <chainedmapper>
            <globmapper from="${top.level.dir}*" to="${filtered.pom.templates.dir}*"/>
            <globmapper from="*build.xml" to="*/src/java/pom.xml"/>
          </chainedmapper>
        </mapper>
        <path location="${ant.file}"/>
      </pathconvert>
      <m2-deploy pom.xml="${pom.xml}">
        <artifact-attachments>
          <attach file="${build.dir}/${final.name}-src.jar"
                  classifier="sources"/>
          <attach file="${build.dir}/${final.name}-javadoc.jar"
                  classifier="javadoc"/>
        </artifact-attachments>
      </m2-deploy>
    </sequential>
  </target>
  
  <target name="-validate-maven-dependencies.init">
    <!-- find the correct pom.xml path and assigns it to property pom.xml -->
    <property name="top.level.dir" location="${common.dir}/.."/>
    <pathconvert property="maven.pom.xml">
      <mapper>
        <chainedmapper>
          <globmapper from="${top.level.dir}*" to="${filtered.pom.templates.dir}*"/>
          <globmapper from="*build.xml" to="*pom.xml"/>
        </chainedmapper>
      </mapper>
      <path location="${ant.file}"/>
    </pathconvert>
    
    <!-- convert ${version} to be a glob pattern, so snapshot versions are allowed: -->
    <loadresource property="maven.version.glob">
      <propertyresource name="version"/>
      <filterchain>
        <tokenfilter>
          <filetokenizer/>
          <replacestring from="-SNAPSHOT" to="-*"/>
        </tokenfilter>
      </filterchain>
    </loadresource>
  </target>
  
  <target name="-validate-maven-dependencies" depends="-validate-maven-dependencies.init">
    <m2-validate-dependencies pom.xml="${maven.pom.xml}" licenseDirectory="${license.dir}">
      <additional-filters>
        <replaceregex pattern="jetty([^/]+)$" replace="jetty" flags="gi" />
        <replaceregex pattern="slf4j-([^/]+)$" replace="slf4j" flags="gi" />
        <replaceregex pattern="javax\.servlet([^/]+)$" replace="javax.servlet" flags="gi" />
      </additional-filters>
      <excludes>
        <rsel:name name="**/lucene-*-${maven.version.glob}.jar" handledirsep="true"/>
      </excludes>
    </m2-validate-dependencies>
  </target>
  
  <property name="module.dependencies.properties.file" location="${common.build.dir}/module.dependencies.properties"/>

  <target name="-append-module-dependencies-properties">
    <sequential>
      <property name="top.level.dir" location="${common.dir}/.."/>
      <pathconvert property="classpath.list" pathsep="," dirsep="/" setonempty="true">
        <path refid="classpath"/>
        <globmapper from="${top.level.dir}/*" to="*" handledirsep="true"/>
      </pathconvert>
      <pathconvert property="test.classpath.list" pathsep="," dirsep="/" setonempty="true">
        <path refid="test.classpath"/>
        <globmapper from="${top.level.dir}/*" to="*" handledirsep="true"/>
      </pathconvert>
      <echo append="true" file="${module.dependencies.properties.file}">
${ant.project.name}.dependencies=${classpath.list}
${ant.project.name}.test.dependencies=${test.classpath.list}
      </echo>
    </sequential>
  </target>

  <property name="maven.dependencies.filters.file" location="${common.build.dir}/maven.dependencies.filters.properties"/>

  <target name="-get-maven-dependencies" depends="compile-tools,load-custom-tasks">
    <ant dir="${common.dir}/.." target="-append-all-modules-dependencies-properties" inheritall="false"/>
    <get-maven-dependencies-macro
        dir="${common.dir}/.."
        centralized.versions.file="${common.dir}/ivy-versions.properties"
        module.dependencies.properties.file="${module.dependencies.properties.file}"
        maven.dependencies.filters.file="${maven.dependencies.filters.file}"/>
  </target>

  <target name="-get-maven-poms" depends="-get-maven-dependencies">
    <property name="maven-build-dir" location="${common.dir}/../maven-build"/>
    <copy todir="${maven-build-dir}" overwrite="true" encoding="UTF-8">
      <fileset dir="${common.dir}/../dev-tools/maven"/>
      <filterset begintoken="@" endtoken="@">
        <filter token="version" value="${version}"/>
        <filter token="version.base" value="${version.base}"/>
        <filter token="spec.version" value="${spec.version}"/>
      </filterset>
      <filterset>
        <filtersfile file="${maven.dependencies.filters.file}"/>
      </filterset>
      <globmapper from="*.template" to="*"/>
    </copy>
  </target>

  <target name="-filter-pom-templates" depends="-get-maven-dependencies">
    <mkdir dir="${filtered.pom.templates.dir}"/>
    <copy todir="${common.dir}/build/poms" overwrite="true" encoding="UTF-8" filtering="on">
      <fileset dir="${common.dir}/../dev-tools/maven"/>
      <filterset begintoken="@" endtoken="@">
        <filter token="version" value="${version}"/>
      </filterset>
      <filterset>
        <filtersfile file="${maven.dependencies.filters.file}"/>
      </filterset>
      <globmapper from="*.template" to="*"/>
    </copy>
  </target>

  <target name="stage-maven-artifacts">
    <sequential>
      <property name="output.build.xml" location="${build.dir}/stage_maven_build.xml"/>
      <property name="dev-tools.scripts.dir" value="../dev-tools/scripts"/>
      <exec dir="." executable="${perl.exe}" failonerror="false" outputproperty="stage.maven.script.output"
        resultproperty="stage.maven.script.success">
        <arg value="-CSD"/>
        <arg value="${dev-tools.scripts.dir}/write.stage.maven.build.xml.pl"/>
        <arg value="${maven.dist.dir}"/>              <!-- Maven distribution artifacts directory -->
        <arg value="${output.build.xml}"/>            <!-- Ant build file to be written -->
        <arg value="${common.dir}/common-build.xml"/> <!-- Imported from the ant file to be written -->
        <arg value="${m2.credentials.prompt}"/>
        <arg value="${m2.repository.id}"/>
        <arg value="${m2.repository.url}"/>
      </exec>
      <echo message="${stage.maven.script.output}"/>
      <fail message="maven stage script failed!">
        <condition>
          <not>
            <equals arg1="${stage.maven.script.success}" arg2="0"/>
          </not>
        </condition>
      </fail>
    </sequential>
    <echo>Invoking target stage-maven in ${output.build.xml} now...</echo>
    <ant target="stage-maven" antfile="${output.build.xml}" inheritall="false">
      <property name="m2.repository.id" value="${m2.repository.id}"/>
      <property name="m2.repository.url" value="${m2.repository.url}"/>
    </ant>
  </target>

  <target name="rat-sources-typedef" unless="rat.loaded" depends="ivy-availability-check,ivy-configure">
    <ivy:cachepath organisation="org.apache.rat" module="apache-rat" revision="0.11" transitive="false" inline="true" conf="master" type="jar" pathid="rat.classpath"/>
    <typedef resource="org/apache/rat/anttasks/antlib.xml" uri="antlib:org.apache.rat.anttasks" classpathref="rat.classpath"/>
    <property name="rat.loaded" value="true"/>
  </target>

  <target name="rat-sources" depends="rat-sources-typedef"
    description="runs the tasks over source and test files">
    <!-- create a temp file for the log to go to -->
    <tempfile property="rat.sources.logfile"
              prefix="rat"
              destdir="${java.io.tmpdir}"/>
    <!-- run rat, going to the file -->
    <rat:report xmlns:rat="antlib:org.apache.rat.anttasks" 
                reportFile="${rat.sources.logfile}" addDefaultLicenseMatchers="true">
      <fileset dir="." includes="*.xml ${rat.additional-includes}" excludes="${rat.additional-excludes}"/>
      <fileset dir="${src.dir}" excludes="${rat.excludes}" erroronmissingdir="false"/>
      <fileset dir="${tests.src.dir}" excludes="${rat.excludes}" erroronmissingdir="false"/>

      <!-- TODO: Check all resource files. Currently not all stopword and similar files have no header! -->
      <fileset dir="${resources.dir}" includes="META-INF/**" erroronmissingdir="false"/>
      
      <!-- BSD 4-clause stuff (is disallowed below) -->
      <rat:substringMatcher licenseFamilyCategory="BSD4 "
             licenseFamilyName="Original BSD License (with advertising clause)">
        <pattern substring="All advertising materials"/>
      </rat:substringMatcher>

      <!-- BSD-like stuff -->
      <rat:substringMatcher licenseFamilyCategory="BSD  "
             licenseFamilyName="Modified BSD License">
      <!-- brics automaton -->
        <pattern substring="Copyright (c) 2001-2009 Anders Moeller"/>
      <!-- snowball -->
        <pattern substring="Copyright (c) 2001, Dr Martin Porter"/>
      <!-- UMASS kstem -->
        <pattern substring="THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF MASSACHUSETTS AND OTHER CONTRIBUTORS"/>
      <!-- Egothor -->
        <pattern substring="Egothor Software License version 1.00"/>
      <!-- JaSpell -->
        <pattern substring="Copyright (c) 2005 Bruno Martins"/>
      <!-- d3.js -->
        <pattern substring="THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS"/>
      <!-- highlight.js -->
        <pattern substring="THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS"/>
      </rat:substringMatcher>

      <!-- MIT-like -->
      <rat:substringMatcher licenseFamilyCategory="MIT  "
             licenseFamilyName="The MIT License">
      <!-- ICU license -->
        <pattern substring="Permission is hereby granted, free of charge, to any person obtaining a copy"/>
      </rat:substringMatcher>

      <!-- Apache -->
      <rat:substringMatcher licenseFamilyCategory="AL   "
             licenseFamilyName="Apache">
        <pattern substring="Licensed to the Apache Software Foundation (ASF) under"/>
        <!-- this is the old-school one under some files -->
        <pattern substring="Licensed under the Apache License, Version 2.0 (the &quot;License&quot;)"/>
      </rat:substringMatcher>

      <rat:substringMatcher licenseFamilyCategory="GEN  "
             licenseFamilyName="Generated">
      <!-- svg files generated by gnuplot -->
        <pattern substring="Produced by GNUPLOT"/>
      <!-- snowball stemmers generated by snowball compiler -->
        <pattern substring="This file was generated automatically by the Snowball to Java compiler"/>
      <!-- uima tests generated by JCasGen -->
        <pattern substring="First created by JCasGen"/>
      <!-- parsers generated by antlr -->
        <pattern substring="ANTLR GENERATED CODE"/>
      </rat:substringMatcher>

      <!-- built in approved licenses -->
      <rat:approvedLicense familyName="Apache"/>
      <rat:approvedLicense familyName="The MIT License"/>
      <rat:approvedLicense familyName="Modified BSD License"/>
      <rat:approvedLicense familyName="Generated"/>
    </rat:report>
    <!-- now print the output, for review -->
    <loadfile property="rat.output" srcFile="${rat.sources.logfile}"/>
    <echo taskname="rat">${rat.output}</echo>
    <delete>
      <fileset file="${rat.sources.logfile}">
        <and>
          <containsregexp expression="^0 Unknown Licenses"/>
          <not>
            <containsregexp expression="^\s+!"/>
          </not>
        </and>
      </fileset>
    </delete>
    <!-- fail if we didnt find the pattern -->
    <fail message="Rat problems were found!">
      <condition>
        <available file="${rat.sources.logfile}"/>
      </condition>
    </fail>
  </target>

  <!--+
      | M A C R O S
      +-->
  <macrodef name="compile">
    <attribute name="srcdir"/>
    <attribute name="destdir"/>
    <attribute name="javac.release" default="${javac.release}"/>
    <attribute name="includeantruntime" default="${javac.includeAntRuntime}" />

    <element name="nested" implicit="yes" optional="yes"/>

    <sequential>
      <local name="javac.release.args"/>
      <condition property="javac.release.args" value="-source @{javac.release} -target @{javac.release}" else="--release @{javac.release}">
        <equals arg1="${build.java.runtime}" arg2="1.8"/>
      </condition>
      <mkdir dir="@{destdir}"/>
      <javac
        includeAntRuntime="@{includeantruntime}"
        encoding="${build.encoding}"
        srcdir="@{srcdir}"
        destdir="@{destdir}"
        deprecation="${javac.deprecation}"
        debug="${javac.debug}">
        <nested/>
        <!-- <compilerarg line="-Xmaxwarns 10000000"/>
        <compilerarg line="-Xmaxerrs 10000000"/> -->
        <compilerarg line="${javac.args}"/>
        <compilerarg line="${javac.profile.args}"/>
        <compilerarg line="${javac.release.args}"/>
        <compilerarg line="${javac.doclint.args}"/>
      </javac>
    </sequential>
  </macrodef>

  <!-- ECJ Javadoc linting: -->
  
  <condition property="ecj-javadoc-lint.supported">
    <equals arg1="${build.java.runtime}" arg2="1.8"/>
  </condition>

  <condition property="ecj-javadoc-lint-tests.supported">
    <and>
      <isset property="ecj-javadoc-lint.supported"/>
      <isset property="module.has.tests"/>
    </and>
  </condition>

  <target name="-ecj-javadoc-lint-unsupported" unless="ecj-javadoc-lint.supported">
    <fail message="Linting documentation with ECJ is not supported on this Java version (${build.java.runtime}).">
      <condition>
        <not><isset property="is.jenkins.build"/></not>
      </condition>
    </fail>
    <echo level="warning" message="WARN: Linting documentation with ECJ is not supported on this Java version (${build.java.runtime}). NOTHING DONE!"/>
  </target>

  <target name="-ecj-javadoc-lint" depends="-ecj-javadoc-lint-unsupported,-ecj-javadoc-lint-src,-ecj-javadoc-lint-tests"/>

  <target name="-ecj-javadoc-lint-src" depends="-ecj-resolve" if="ecj-javadoc-lint.supported">
    <ecj-macro srcdir="${src.dir}" configuration="${common.dir}/tools/javadoc/ecj.javadocs.prefs">
      <classpath refid="classpath"/>
    </ecj-macro>
  </target>

  <target name="-ecj-javadoc-lint-tests" depends="-ecj-resolve" if="ecj-javadoc-lint-tests.supported">
    <ecj-macro srcdir="${tests.src.dir}" configuration="${common.dir}/tools/javadoc/ecj.javadocs.prefs">
      <classpath refid="test.classpath"/>
    </ecj-macro>
  </target>
  
  <target name="-ecj-resolve" unless="ecj.loaded" depends="ivy-availability-check,ivy-configure" if="ecj-javadoc-lint.supported">
    <ivy:cachepath organisation="org.eclipse.jdt.core.compiler" module="ecj" revision="4.4.1"
     inline="true" conf="master" type="jar" pathid="ecj.classpath" />
    <componentdef classname="org.eclipse.jdt.core.JDTCompilerAdapter"
     classpathref="ecj.classpath" name="ecj-component"/>
    <property name="ecj.loaded" value="true"/>
  </target>

  <macrodef name="ecj-macro">
    <attribute name="srcdir"/>
    <attribute name="javac.release" default="${javac.release}"/>
    <attribute name="includeantruntime" default="${javac.includeAntRuntime}" />
    <attribute name="configuration"/>

    <element name="nested" implicit="yes" optional="yes"/>

    <sequential>
      <!-- hack: we can tell ECJ not to create classfiles, but it still creates
           package-info.class files. so redirect output to a tempdir -->
      <tempfile property="ecj.trash.out" destdir="${java.io.tmpdir}" prefix="ecj"/>
      <mkdir dir="${ecj.trash.out}"/>
      <javac
        includeAntRuntime="@{includeantruntime}"
        encoding="${build.encoding}"
        srcdir="@{srcdir}"
        destdir="${ecj.trash.out}"
        source="@{javac.release}"
        target="@{javac.release}"
        taskname="ecj-lint">
        <ecj-component/>
        <nested/>
      <!-- hack: we can't disable classfile creation right now, because we need
           to specify a destination for buggy package-info.class files
        <compilerarg value="-d"/>
        <compilerarg value="none"/> -->
        <compilerarg value="-enableJavadoc"/>
        <compilerarg value="-properties"/>
        <compilerarg value="@{configuration}"/>
      </javac>
      <delete dir="${ecj.trash.out}"/>
    </sequential>
  </macrodef>

  <!-- TODO: if we make a custom ant task, we can give better
       errors and stuff here, and not make a stupid temp dir -->
  <macrodef name="jtidy-macro">
    <element name="nested" implicit="yes" optional="yes"/>
    <sequential>
      <ivy:cachepath organisation="net.sf.jtidy" module="jtidy" revision="r938"
          log="download-only" inline="true" conf="master" type="jar" pathid="jtidy.classpath" />
      <taskdef name="tidy" classname="org.w3c.tidy.ant.JTidyTask" classpathref="jtidy.classpath"/>
      <delete dir="${common.dir}/build/jtidy_tmp" quiet="true"/>
      <echo message="Checking for broken html (such as invalid tags)..." taskname="jtidy"/>
      <tidy failonerror="true" destdir="${common.dir}/build/jtidy_tmp">
         <nested/>
         <parameter name="input-encoding" value="UTF-8" />
         <parameter name="only-errors" value="true" />
         <parameter name="show-warnings" value="false" />
      </tidy>
      <delete dir="${common.dir}/build/jtidy_tmp" quiet="true"/>
    </sequential>
  </macrodef>

  <property name="failonjavadocwarning" value="true"/>
  <macrodef name="invoke-javadoc">
    <element name="sources" optional="yes"/>
    <attribute name="destdir"/>
    <attribute name="title" default="${Name} ${version} API"/>
    <attribute name="overview" default="${src.dir}/overview.html"/>
    <attribute name="linksource" default="no"/>
    <sequential>
      <local name="javadoc.release.args"/>
      <condition property="javadoc.release.args" value="-source ${javac.release}" else="--release ${javac.release}">
        <equals arg1="${build.java.runtime}" arg2="1.8"/>
      </condition>
      <antcall target="download-java8-javadoc-packagelist"/>
      <delete file="@{destdir}/stylesheet.css" failonerror="false"/>
      <delete file="@{destdir}/script.js" failonerror="false"/>
      <record name="@{destdir}/log_javadoc.txt" action="start" append="no"/>
      <javadoc
          overview="@{overview}"
          packagenames="org.apache.lucene.*,org.apache.solr.*"
          destdir="@{destdir}"
          access="${javadoc.access}"
          encoding="${build.encoding}"
          charset="${javadoc.charset}"
          docencoding="${javadoc.charset}"
          noindex="${javadoc.noindex}"
          includenosourcepackages="true"
          author="true"
          version="true"
          linksource="@{linksource}"
          use="true"
          failonerror="true"
          locale="en_US"
          windowtitle="${Name} ${version} API"
          doctitle="@{title}"
          maxmemory="${javadoc.maxmemory}">
        <tag name="lucene.experimental" 
          description="WARNING: This API is experimental and might change in incompatible ways in the next release."/>
        <tag name="lucene.internal"
        description="NOTE: This API is for internal purposes only and might change in incompatible ways in the next release."/>
        <link offline="true" packagelistLoc="${javadoc.dir}"/>
        <link offline="true" href="${javadoc.link}" packagelistLoc="${javadoc.packagelist.dir}/java8"/>
        <bottom><![CDATA[
          <i>Copyright &copy; ${year} Apache Software Foundation.  All Rights Reserved.</i>
        ]]></bottom>
        
        <sources />
                
        <classpath refid="javadoc.classpath"/>
        <arg line="${javadoc.release.args}"/>
        <arg line="${javadoc.doclint.args}"/>
      </javadoc>
      <record name="@{destdir}/log_javadoc.txt" action="stop"/>
      
      <!-- append prettify to scripts and css -->
      <concat destfile="@{destdir}/stylesheet.css" append="true" fixlastline="true" encoding="UTF-8">
        <filelist dir="${prettify.dir}" files="prettify.css"/>
      </concat>
      <concat destfile="@{destdir}/script.js" append="true" fixlastline="true" encoding="UTF-8">
        <filelist dir="${prettify.dir}" files="prettify.js inject-javadocs.js"/>
      </concat>
      <fixcrlf srcdir="@{destdir}" includes="stylesheet.css script.js" eol="lf" fixlast="true" encoding="UTF-8" />

      <delete>
        <fileset file="@{destdir}/log_javadoc.txt">
          <or>
            <not>
              <containsregexp expression="\[javadoc\]\s*[1-9][0-9]*\s*warning"/>
            </not>
            <and>
              <!-- allow 1 warning, if there is also a bootstrap warning generated by Java7 -->
              <containsregexp expression="\[javadoc\]\s*warning.*bootstrap"/>
              <containsregexp expression="\[javadoc\]\s*1\s*warning"/>
            </and>
          </or>
        </fileset>
      </delete>

      <fail message="Javadocs warnings were found!">
        <condition>
          <and>
            <available file="@{destdir}/log_javadoc.txt"/>
            <istrue value="${failonjavadocwarning}"/>
          </and>
        </condition>
      </fail>
   </sequential>
  </macrodef>

  <target name="check-javadocs-uptodate">
    <uptodate property="javadocs-uptodate-${name}" targetfile="${build.dir}/${final.name}-javadoc.jar">
      <srcfiles dir="${src.dir}">
        <include name="**/*.java"/>
        <include name="**/*.html"/>
      </srcfiles>
    </uptodate>
  </target>

  <macrodef name="modules-crawl">
    <attribute name="target" default=""/>
    <attribute name="failonerror" default="true"/>
    <sequential>
      <subant target="@{target}" failonerror="@{failonerror}" inheritall="false">
        <propertyset refid="uptodate.and.compiled.properties"/>
        <fileset dir="." includes="*/build.xml" excludes="build/**,core/**,test-framework/**,tools/**"/>
      </subant>
    </sequential>
  </macrodef>

  <target name="download-java8-javadoc-packagelist" unless="javadoc.java8.packagelist.exists">
    <mkdir dir="${javadoc.packagelist.dir}/java8"/>
    <get src="${javadoc.link}/package-list"
         dest="${javadoc.packagelist.dir}/java8/package-list" ignoreerrors="true"/>
  </target>

  <!-- VALIDATION work -->

  <!-- Generic placeholder target for if we add other validation tasks -->
  <target name="validate">
  </target>

  <property name="src.export.dir" location="${build.dir}/src-export"/>
  <macrodef name="export-source"
            description="Exports the source to src.export.dir.">
    <attribute name="source.dir"/>
    <sequential>
      <delete dir="${src.export.dir}" includeemptydirs="true" failonerror="false"/>
      <exec dir="@{source.dir}" executable="${git.exe}" failonerror="true">
        <arg value="checkout-index"/>
        <arg value="-a"/>
        <arg value="-f"/>
        <arg value="--prefix=${src.export.dir}/"/>
      </exec>
    </sequential>
  </macrodef>

  <macrodef name="make-checksums" description="Macro for building checksum files">
    <attribute name="file"/>
    <sequential>
      <echo>Building checksums for '@{file}'</echo>
      <checksum file="@{file}" algorithm="md5" format="MD5SUM" forceoverwrite="yes" readbuffersize="65536"/>
      <checksum file="@{file}" algorithm="sha1" format="MD5SUM" forceoverwrite="yes" readbuffersize="65536"/>
    </sequential>
  </macrodef>

  <macrodef name="jar-checksum-macro">
      <attribute name="srcdir"/>
      <attribute name="dstdir"/>
    <sequential>
      <delete>
        <fileset dir="@{dstdir}">
          <include name="**/*.jar.sha1"/>
        </fileset>
      </delete>

      <!-- checksum task does not have a flatten=true -->
      <tempfile property="jar-checksum.temp.dir"/>
      <mkdir dir="${jar-checksum.temp.dir}"/>
      <copy todir="${jar-checksum.temp.dir}" flatten="true">
        <fileset dir="@{srcdir}">
          <include name="**/*.jar"/>
          <!-- todo make this something passed into the macro and not some hardcoded set -->
          <exclude name="build/**"/>
          <exclude name="dist/**"/>
          <exclude name="package/**"/>
          <exclude name="example/exampledocs/**"/>
        </fileset>
      </copy>

      <checksum algorithm="SHA1" fileext=".sha1" todir="@{dstdir}">
        <fileset dir="${jar-checksum.temp.dir}"/>
      </checksum>

      <delete dir="${jar-checksum.temp.dir}"/>

      <fixcrlf 
        srcdir="@{dstdir}"
        includes="**/*.jar.sha1"
        eol="lf" fixlast="true" encoding="US-ASCII" />
    </sequential>
  </macrodef>

  <macrodef name="sign-artifacts-macro">
    <attribute name="artifacts.dir"/>
    <sequential>
      <delete failonerror="false">
        <fileset dir="@{artifacts.dir}">
          <include name="**/*.asc"/>
        </fileset>
      </delete>

      <available property="gpg.input.handler" classname="org.apache.tools.ant.input.SecureInputHandler"
                 value="org.apache.tools.ant.input.SecureInputHandler"/>
      <!--else:--><property name="gpg.input.handler" value="org.apache.tools.ant.input.DefaultInputHandler"/>
      <echo>WARNING: ON SOME PLATFORMS YOUR PASSPHRASE WILL BE ECHOED BACK!!!!!</echo>
      <input message="Enter GPG keystore password: >" addproperty="gpg.passphrase">
        <handler classname="${gpg.input.handler}" />
      </input>

      <apply executable="${gpg.exe}" inputstring="${gpg.passphrase}"
             dest="@{artifacts.dir}" type="file" maxparallel="1" verbose="yes">
        <arg value="--passphrase-fd"/>
        <arg value="0"/>
        <arg value="--batch"/>
        <arg value="--armor"/>
        <arg value="--default-key"/>
        <arg value="${gpg.key}"/>
        <arg value="--output"/>
        <targetfile/>
        <arg value="--detach-sig"/>
        <srcfile/>

        <fileset dir="@{artifacts.dir}">
          <include name="**/*.jar"/>
          <include name="**/*.war"/>
          <include name="**/*.zip"/>
          <include name="**/*.tgz"/>
          <include name="**/*.pom"/>
        </fileset>
        <globmapper from="*" to="*.asc"/>
      </apply>
    </sequential>
  </macrodef>

  <property name="rc" value="rc0"/>
  <property name="remote.staging.dir" value="public_html/staging_area/${rc}/${version}"/>
  <property name="keyfile" value="${user.home}/.ssh/id_rsa"/>
  <property name="scp.user" value="${user.name}"/>
  <!--keys.dir is the location of the https://svn.apache.org/repos/asf/lucene/java/dist/ directory-->
  <property name="keys.dir" value="${common.dir}/../../dist"/>
  <macrodef name="copy-to-stage-macro">
    <attribute name="artifacts.dir"/>
    <sequential>
      <sshexec host="home.apache.org"
               username="${scp.user}"
               keyfile="${keyfile}"
               command="mkdir -p ${remote.staging.dir}"/>
      <echo>Uploading artifacts to ${scp.user}@home.apache.org:${remote.staging.dir}</echo>
      <scp todir="${scp.user}@home.apache.org:${remote.staging.dir}"
           username="${scp.user}"
           keyfile="${keyfile}"
           verbose="true">
        <fileset dir="${artifacts.dir}"/>
        <fileset dir="${keys.dir}">
          <include name="KEYS"/>
        </fileset>
      </scp>
    </sequential>
  </macrodef>

  <!-- JFlex task -->
  <target name="-install-jflex" unless="jflex.loaded" depends="ivy-availability-check,ivy-configure">
    <ivy:cachepath organisation="de.jflex" module="jflex" revision="1.6.0"
                   inline="true" conf="default" transitive="true" pathid="jflex.classpath"/>
    <taskdef name="jflex" classname="jflex.anttask.JFlexTask" classpathref="jflex.classpath"/>
    <property name="jflex.loaded" value="true"/>
  </target>

  <!-- GROOVY scripting engine for ANT tasks -->
  <target name="resolve-groovy" unless="groovy.loaded" depends="ivy-availability-check,ivy-configure">
    <ivy:cachepath organisation="org.codehaus.groovy" module="groovy-all" revision="2.4.12"
      inline="true" conf="default" type="jar" transitive="true" pathid="groovy.classpath"/>
    <taskdef name="groovy"
      classname="org.codehaus.groovy.ant.Groovy"
      classpathref="groovy.classpath"/>
    <property name="groovy.loaded" value="true"/>
  </target>
  
  <!-- Forbidden API Task -->
  <property name="forbidden-base-excludes" value=""/>
  <property name="forbidden-tests-excludes" value=""/>
  <property name="forbidden-sysout-excludes" value=""/>
  
  <target name="-install-forbidden-apis" unless="forbidden-apis.loaded" depends="ivy-availability-check,ivy-configure">
    <ivy:cachepath organisation="de.thetaphi" module="forbiddenapis" revision="2.4.1"
      inline="true" conf="default" transitive="true" pathid="forbidden-apis.classpath"/>
    <taskdef name="forbidden-apis" classname="de.thetaphi.forbiddenapis.ant.AntTask" classpathref="forbidden-apis.classpath"/>
    <property name="forbidden-apis.loaded" value="true"/>
  </target>  

  <target name="-init-forbidden-apis" depends="-install-forbidden-apis">
    <path id="forbidden-apis.allclasses.classpath">
      <path refid="classpath"/>
      <path refid="test.classpath"/>
      <path refid="junit-path"/>
      <!-- include the output directories, too (so we can still resolve excluded classes: -->
      <pathelement path="${build.dir}/classes/java"/>
      <pathelement path="${build.dir}/classes/test"/>
    </path>
  </target>  

  <condition property="forbidden-isLucene">
    <not>
      <or>
        <matches pattern="^(solr)\b" string="${name}"/>
        <matches pattern="tools" string="${name}"/>
      </or>
    </not>
  </condition>

  <target name="check-forbidden-apis" depends="-check-forbidden-all,-check-forbidden-core,-check-forbidden-tests" description="Check forbidden API calls in compiled class files"/>
  
  <!-- applies to both source and test code -->
  <target name="-check-forbidden-all" depends="-init-forbidden-apis,compile-core,compile-test">
    <forbidden-apis suppressAnnotation="**.SuppressForbidden" classpathref="forbidden-apis.allclasses.classpath" targetVersion="${javac.release}">
      <signatures>
        <bundled name="jdk-unsafe"/>
        <bundled name="jdk-deprecated"/>
        <bundled name="jdk-non-portable"/>
        <bundled name="jdk-reflection"/>
        <fileset dir="${common.dir}/tools/forbiddenApis">
          <include name="base.txt"/>
          <include name="lucene.txt" if="forbidden-isLucene"/>
        </fileset>
      </signatures>
      <fileset dir="${build.dir}/classes/java" excludes="${forbidden-base-excludes}"/>
      <fileset dir="${build.dir}/classes/test" excludes="${forbidden-tests-excludes}" erroronmissingdir="false"/>
    </forbidden-apis>
  </target>

  <!-- applies to only test code -->
  <target name="-check-forbidden-tests" depends="-init-forbidden-apis,compile-test">
    <forbidden-apis signaturesFile="${common.dir}/tools/forbiddenApis/tests.txt" suppressAnnotation="**.SuppressForbidden" classpathref="forbidden-apis.allclasses.classpath" targetVersion="${javac.release}"> 
      <fileset dir="${build.dir}/classes/test" excludes="${forbidden-tests-excludes}"/>
    </forbidden-apis>
  </target>
 
  <!-- applies to only source code -->
  <target name="-check-forbidden-core" depends="-init-forbidden-apis,compile-core,-check-forbidden-sysout" />

  <target name="-check-forbidden-sysout" depends="-init-forbidden-apis,compile-core">
    <forbidden-apis bundledSignatures="jdk-system-out" suppressAnnotation="**.SuppressForbidden" classpathref="forbidden-apis.allclasses.classpath" targetVersion="${javac.release}">
      <fileset dir="${build.dir}/classes/java" excludes="${forbidden-sysout-excludes}"/>
    </forbidden-apis>
  </target>

  <target name="resolve-markdown" unless="markdown.loaded" depends="resolve-groovy">
    <property name="flexmark.version" value="0.16.1"/>
    <ivy:cachepath transitive="true" pathid="markdown.classpath">
      <ivy:dependency org="com.vladsch.flexmark" name="flexmark" rev="${flexmark.version}" conf="default" />
      <ivy:dependency org="com.vladsch.flexmark" name="flexmark-ext-autolink" rev="${flexmark.version}" conf="default" />
      <ivy:dependency org="com.vladsch.flexmark" name="flexmark-ext-abbreviation" rev="${flexmark.version}" conf="default" />
    </ivy:cachepath>
    <groovy classpathref="markdown.classpath"><![CDATA[
      import org.apache.tools.ant.AntTypeDefinition;
      import org.apache.tools.ant.ComponentHelper;
      import org.apache.tools.ant.filters.TokenFilter.ChainableReaderFilter;
      import com.vladsch.flexmark.ast.Node;
      import com.vladsch.flexmark.ast.Heading;
      import com.vladsch.flexmark.html.HtmlRenderer;
      import com.vladsch.flexmark.parser.Parser;
      import com.vladsch.flexmark.parser.ParserEmulationProfile;
      import com.vladsch.flexmark.util.html.Escaping;
      import com.vladsch.flexmark.util.options.MutableDataSet;
      import com.vladsch.flexmark.ext.abbreviation.AbbreviationExtension;
      import com.vladsch.flexmark.ext.autolink.AutolinkExtension;
      
      public final class MarkdownFilter extends ChainableReaderFilter {
        @Override
        public String filter(String markdownSource) {
          MutableDataSet options = new MutableDataSet();
          options.setFrom(ParserEmulationProfile.MARKDOWN);
          options.set(Parser.EXTENSIONS, [ AbbreviationExtension.create(), AutolinkExtension.create() ]);
          options.set(HtmlRenderer.RENDER_HEADER_ID, true);
          options.set(HtmlRenderer.MAX_TRAILING_BLANK_LINES, 0);
          Node parsed = Parser.builder(options).build().parse(markdownSource);

          StringBuilder html = new StringBuilder('<html>\n<head>\n');
          CharSequence title = parsed.getFirstChildAny(Heading.class)?.getText();          
          if (title != null) {
            html.append('<title>').append(Escaping.escapeHtml(title, false)).append('</title>\n');
          }
          html.append('<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">\n')
            .append('</head>\n<body>\n');
          HtmlRenderer.builder(options).build().render(parsed, html);
          html.append('</body>\n</html>\n');
          return html;
        }
      }
      
      AntTypeDefinition t = new AntTypeDefinition();
      t.setName('markdownfilter');
      t.setClass(MarkdownFilter.class);
      ComponentHelper.getComponentHelper(project).addDataTypeDefinition(t);
    ]]></groovy>
    <property name="markdown.loaded" value="true"/>
  </target>
  
  <!-- markdown macro: Before using depend on the target "resolve-markdown" -->
  
  <macrodef name="markdown">
    <attribute name="todir"/>
    <attribute name="flatten" default="false"/>
    <attribute name="overwrite" default="false"/>
    <element name="nested" optional="false" implicit="true"/>
    <sequential>
      <copy todir="@{todir}" flatten="@{flatten}" overwrite="@{overwrite}" verbose="true"
        preservelastmodified="false" encoding="UTF-8" taskname="markdown"
      >
        <filterchain>
          <tokenfilter>
            <filetokenizer/>
            <replaceregex pattern="\b(LUCENE|SOLR)\-\d+\b" replace="[\0](https://issues.apache.org/jira/browse/\0)" flags="gs"/>
            <markdownfilter/>
          </tokenfilter>
        </filterchain>
        <nested/>
      </copy>
    </sequential>
  </macrodef>

  <target name="regenerate"/>
  
  <macrodef name="check-broken-links">
       <attribute name="dir"/>
     <sequential>
       <exec dir="." executable="${python32.exe}" failonerror="true">
         <!-- Tell Python not to write any bytecode cache into the filesystem: -->
         <arg value="-B"/>
         <arg value="${dev-tools.dir}/scripts/checkJavadocLinks.py"/>
         <arg value="@{dir}"/>
       </exec>
     </sequential>
  </macrodef>

  <macrodef name="check-missing-javadocs">
       <attribute name="dir"/>
       <attribute name="level" default="class"/>
     <sequential>
       <exec dir="." executable="${python32.exe}" failonerror="true">
         <!-- Tell Python not to write any bytecode cache into the filesystem: -->
         <arg value="-B"/>
         <arg value="${dev-tools.dir}/scripts/checkJavaDocs.py"/>
         <arg value="@{dir}"/>
         <arg value="@{level}"/>
       </exec>
     </sequential>
  </macrodef>

  <!--
   compile changes.txt into an html file
   -->
  <macrodef name="build-changes">
    <attribute name="changes.product"/>
    <attribute name="doap.property.prefix" default="doap.@{changes.product}"/>
    <attribute name="changes.src.file" default="CHANGES.txt"/>
    <attribute name="changes.src.doap" default="${dev-tools.dir}/doap/@{changes.product}.rdf"/>
    <attribute name="changes.version.dates" default="build/@{doap.property.prefix}.version.dates.csv"/>
    <attribute name="changes.target.dir" default="${changes.target.dir}"/>
    <attribute name="lucene.javadoc.url" default="${lucene.javadoc.url}"/>
    <sequential>
      <mkdir dir="@{changes.target.dir}"/>
      <xmlproperty keeproot="false" file="@{changes.src.doap}" collapseAttributes="false" prefix="@{doap.property.prefix}"/>
      <echo file="@{changes.version.dates}" append="false">${@{doap.property.prefix}.Project.release.Version.revision}&#xA;</echo>
      <echo file="@{changes.version.dates}" append="true">${@{doap.property.prefix}.Project.release.Version.created}&#xA;</echo>
      <exec executable="${perl.exe}" input="@{changes.src.file}" output="@{changes.target.dir}/Changes.html"
            failonerror="true" logError="true">
        <arg value="-CSD"/>
        <arg value="${changes.src.dir}/changes2html.pl"/>
        <arg value="@{changes.product}"/>
        <arg value="@{changes.version.dates}"/>
        <arg value="@{lucene.javadoc.url}"/>
      </exec>
      <delete file="@{changes.version.dates}"/>
      <copy todir="@{changes.target.dir}">
        <fileset dir="${changes.src.dir}" includes="*.css"/>
      </copy>
    </sequential>
  </macrodef>

  <macrodef name="pitest-macro" description="Executes junit tests.">
    <attribute name="pitest.report.dir" default="${pitest.report.dir}"/>
    <attribute name="pitest.framework.classpath" default="pitest.framework.classpath"/>
    <attribute name="pitest.distance" default="${pitest.distance}" />
    <attribute name="pitest.sysprops" default="${pitest.sysprops}" />
    <attribute name="pitest.threads" default="${pitest.threads}" />
    <attribute name="pitest.testCases" default="${pitest.testCases}" />
    <attribute name="pitest.maxMutations" default="${pitest.maxMutations}" />
    <attribute name="pitest.timeoutFactor" default="${pitest.timeoutFactor}" />
    <attribute name="pitest.timeoutConst" default="${pitest.timeoutConst}" />
    <attribute name="pitest.targetClasses" default="${pitest.targetClasses}" />

    <attribute name="junit.classpath" default="junit.classpath"/>

    <attribute name="src.dir" default="${src.dir}"/>
    <attribute name="build.dir" default="${build.dir}"/>

    <sequential>

        <echo>
PiTest mutation coverage can take a *long* time on even large hardware.
(EC2 32core sandy bridge takes at least 12 hours to run PiTest for the lucene test cases)

The following arguments can be provided to ant to alter its behaviour and target specific tests::

-Dpitest.report.dir (@{pitest.report.dir}) - Change where PiTest writes output reports

-Dpitest.distance (@{pitest.distance}) - How far away from the test class should be mutated
   0 being immeditate callees only

-Dpitest.threads (@{pitest.threads}) - How many threads to use in PiTest 
   (note this is independent of junit threads)

-Dpitest.testCases (@{pitest.testCases}) - Glob of testcases to run

-Dpitest.maxMutations (@{pitest.maxMutations}) - Maximum number of mutations per class under test
    0 being unlimited

-Dpitest.timeoutFactor (@{pitest.timeoutFactor}) - Tunable factor used to determine
    if a test is potentially been mutated to be an infinate loop or O(n!) (or similar)

-Dpitest.timeoutConst (@{pitest.timeoutConst}) - Base constant used for working out timeouts

-Dpitest.targetClasses (@{pitest.targetClasses}) - Classes to consider for mutation
        </echo>

        <taskdef name="pitest" classname="org.pitest.ant.PitestTask"
            classpathref="pitest.framework.classpath" />

        <path id="pitest.classpath">
            <path refid="junit.classpath"/>
            <path refid="pitest.framework.classpath"/>
            <pathelement path="${java.class.path}"/>
        </path>

        <junit4:pickseed property="pitest.seed" />

        <property name="pitest.sysprops" value="-Dversion=${version},-Dtest.seed=${pitest.seed},-Djava.security.manager=org.apache.lucene.util.TestSecurityManager,-Djava.security.policy=${tests.policy},-Djava.io.tmpdir=${tests.workDir},-Djunit4.childvm.cwd=${tests.workDir},-Djunit4.tempDir=${tests.workDir}" />

        <pitest
            classPath="pitest.classpath"
            targetClasses="@{pitest.targetClasses}"
            targetTests="@{pitest.testCases}"
            reportDir="@{pitest.report.dir}"
            sourceDir="@{src.dir}"
            threads="@{pitest.threads}"
            maxMutationsPerClass="@{pitest.maxMutations}"
            timeoutFactor="@{pitest.timeoutFactor}"
            timeoutConst="@{pitest.timeoutConst}"
            verbose="false"
            dependencyDistance="@{pitest.distance}"
            mutableCodePaths="@{build.dir}/classes/java"
            jvmArgs="-ea,@{pitest.sysprops}" />
    </sequential>
  </macrodef>

  <macrodef name="run-jflex">
    <attribute name="dir"/>
    <attribute name="name"/>
    <sequential>
      <jflex file="@{dir}/@{name}.jflex" outdir="@{dir}" nobak="on" inputstreamctor="false"/>
    </sequential>
  </macrodef>

  <macrodef name="run-jflex-and-disable-buffer-expansion">
    <attribute name="dir"/>
    <attribute name="name"/>
    <sequential>
      <jflex file="@{dir}/@{name}.jflex" outdir="@{dir}" nobak="on" inputstreamctor="false"/>
      <!-- LUCENE-5897: Disallow scanner buffer expansion -->
      <replaceregexp file="@{dir}/@{name}.java"
                     match="[ \t]*/\* is the buffer big enough\? \*/\s+if \(zzCurrentPos >= zzBuffer\.length.*?\}[ \t]*\r?\n"
                     replace="" flags="s" />
      <replaceregexp file="@{dir}/@{name}.java"
                     match="private static final int ZZ_BUFFERSIZE ="
                     replace="private int ZZ_BUFFERSIZE ="/>
      <replaceregexp file="@{dir}/@{name}.java"
                     match="int requested = zzBuffer.length - zzEndRead;"
                     replace="int requested = zzBuffer.length - zzEndRead - zzFinalHighSurrogate;"/>
      <replaceregexp file="@{dir}/@{name}.java"
                     match="(zzFinalHighSurrogate = 1;)(\r?\n)"
                     replace="\1\2          if (totalRead == 1) { return true; }\2"/>
    </sequential>
  </macrodef>


</project>
