apply plugin: 'java-library'

dependencies {
  api project(':lucene:core')
  api project(':lucene:queries')
  api project(':lucene:sandbox')

  testImplementation project(':lucene:test-framework')
}

configure(":lucene:queryparser") {
  configurations {
    javaCCDeps

    dependencies {
      javaCCDeps "net.java.dev.javacc:javacc:5.0"
    }
  }
}
def conf = [
    "queryParser": ["inputFile": file('src/java/org/apache/lucene/queryparser/classic/QueryParser.jj'), "outputDir": file('src/java/org/apache/lucene/queryparser/classic')],
    "surround"   : ["inputFile": file('src/java/org/apache/lucene/queryparser/surround/parser/QueryParser.jj'), "outputDir": file('src/java/org/apache/lucene/queryparser/surround/parser/')],
    "flexible"   : ["inputFile": file('src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.jj'), "outputDir": file('src/java/org/apache/lucene/queryparser/flexible/standard/parser')]
]

String javaCCClasspath
String javaCCHome

task installJavacc {
  doLast {
    javaCCClasspath = project.project(":lucene:queryparser").configurations.javaCCDeps.asPath
    javaCCHome = javaCCClasspath.substring(0, javaCCClasspath.lastIndexOf("/"))

    String hacky = javaCCHome + "/" + "javacc.jar"
    File hackyFile = new File(hacky)
    println hackyFile
    println hackyFile.exists()
    if (hackyFile.exists() == false) {
      hackyFile.bytes = new File(javaCCClasspath).bytes
      hackyFile.setExecutable(true)
    }
  }
}
String lineSeparator = System.lineSeparator()

task cleanOldGeneratedFiles {
  doLast {
    println "Removing old generated files"
    conf.each { key, val ->
      val["outputDir"].eachFileMatch ~/.*\.java/, { f ->
        if (f.text =~ /Generated.*By.*JavaCC/) {
          f.delete()
        }
      }
    }
  }
}

task runJavaccQueryParser(dependsOn: installJavacc) {
  doLast {
    println "Generating QueryParser parser"

    def inputFile = conf["queryParser"]["inputFile"].getAbsolutePath()
    def outputDir = conf["queryParser"]["outputDir"].getAbsolutePath()
    ant.javacc(target: inputFile, outputDirectory: outputDir, javacchome: javaCCHome)


    ant.replaceregexp(file: new File(outputDir, "QueryParser.java"),
        byline: "true",
        match: "public QueryParser\\(CharStream ",
        replace: "protected QueryParser(CharStream ")
    ant.replaceregexp(file: new File(outputDir, "QueryParser.java"),
        byline: "true",
        match: "public QueryParser\\(QueryParserTokenManager ",
        replace: "protected QueryParser(QueryParserTokenManager ")
  }
}

task runJavaccSurround(dependsOn: installJavacc) {
  doLast {
    println "Generating Surroundf parser"
    def inputFile = conf["surround"]["inputFile"].getAbsolutePath()
    def outputDir = conf["surround"]["outputDir"].getAbsolutePath()

    ant.javacc(target: inputFile, outputDirectory: outputDir, javacchome: javaCCHome)

    // This is very clumsy, but these are unused imports that are necessary other generated files
    [
        "import java.util.Vector;",
        "import org.apache.lucene.queryparser.flexible.messages.Message;",
        "import org.apache.lucene.queryparser.flexible.messages.MessageImpl;",
        "import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;",
        "import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;",
        "import org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode;",
        "import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;",
        "import org.apache.lucene.queryparser.flexible.core.nodes.BoostQueryNode;",
        "import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;",
        "import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;",
        "import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;",
        "import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;",
        "import org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode;",
        "import org.apache.lucene.queryparser.flexible.standard.nodes.RegexpQueryNode;",
        "import org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode;",
        "import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;",
        "import org.apache.lucene.queryparser.flexible.core.nodes.QuotedFieldQueryNode;",
        "import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;",
        "import org.apache.lucene.queryparser.flexible.standard.nodes.TermRangeQueryNode;",
        "import java.io.StringReader;",
        "import java.util.ArrayList;",
        "import java.util.Arrays;",
        "import java.util.HashSet;",
        "import java.util.List;",
        "import java.util.Locale;",
        "import java.util.Set;",
        "import org.apache.lucene.analysis.Analyzer;",
        "import org.apache.lucene.document.DateTools;",
        "import org.apache.lucene.search.BooleanClause;",
        "import org.apache.lucene.search.Query;",
        "import org.apache.lucene.search.TermRangeQuery;",
        "import org.apache.lucene.analysis.TokenStream;",
        "import org.apache.lucene.queryparser.surround.query.SrndQuery;",
        "import org.apache.lucene.queryparser.surround.query.FieldsQuery;",
        "import org.apache.lucene.queryparser.surround.query.OrQuery;",
        "import org.apache.lucene.queryparser.surround.query.AndQuery;",
        "import org.apache.lucene.queryparser.surround.query.NotQuery;",
        "import org.apache.lucene.queryparser.surround.query.DistanceQuery;",
        "import org.apache.lucene.queryparser.surround.query.SrndTermQuery;",
        "import org.apache.lucene.queryparser.surround.query.SrndPrefixQuery;",
        "import org.apache.lucene.queryparser.surround.query.SrndTruncQuery;"
    ].each {
      ant.replaceregexp(match: "${it}.*${lineSeparator}", replace: "", encoding: "UTF-8") {
        ant.fileset(dir: outputDir, includes: "*TokenManager.java")
      }
    }
    // StringBuffer -> StringBuilder
    ant.replace(token: "StringBuffer", value: "StringBuilder", encoding: "UTF-8") {
      ant.fileset(dir: outputDir, includes: "ParseException.java TokenMgrError.java")
    }

    [
        "import org.apache.lucene.analysis.TokenStream;",
    ].each {
      ant.replaceregexp(match: "${it}.*${lineSeparator}", replace: "", encoding: "UTF-8") {
        ant.fileset(dir: outputDir, includes: "QueryParser.java")
      }
    }
    // StringBuffer -> StringBuilder
    ant.replace(token: "StringBuffer", value: "StringBuilder", encoding: "UTF-8") {
      ant.fileset(dir: outputDir, includes: "ParseException.java TokenMgrError.java")
    }
  }
}

task runJavaccFlexible(dependsOn: installJavacc) {
  doLast {
    println "Generating flexible parser"
    def inputFile = conf["flexible"]["inputFile"].getAbsolutePath()
    def outputDir = conf["flexible"]["outputDir"].getAbsolutePath()
    ant.javacc(target: inputFile, outputDirectory: outputDir, javacchome: javaCCHome)

    ant.replaceregexp(file: new File(outputDir, "ParseException.java"),
        match: "public class ParseException extends Exception",
        replace: "public class ParseException extends QueryNodeParseException",
        flags: "g",
        byline: "false")
    ant.replaceregexp(file: new File(outputDir, "ParseException.java"),
        match: "package org.apache.lucene.queryparser.flexible.standard.parser;",
        replace: "package org.apache.lucene.queryparser.flexible.standard.parser;${lineSeparator}${lineSeparator}" +
            "import org.apache.lucene.queryparser.flexible.messages.Message;${lineSeparator}" +
            "import org.apache.lucene.queryparser.flexible.messages.MessageImpl;${lineSeparator}" +
            "import org.apache.lucene.queryparser.flexible.core.*;${lineSeparator}" +
            "import org.apache.lucene.queryparser.flexible.core.messages.*;",
        flags: "g",
        byline: "false")
    ant.replaceregexp(file: new File(outputDir, "ParseException.java"),
        match: "^  public ParseException\\(Token currentTokenVal.*\$(\\s\\s[^}].*\\n)*  \\}",
        replace: "  public ParseException(Token currentTokenVal,${lineSeparator}" +
            "    int[][] expectedTokenSequencesVal, String[] tokenImageVal) {${lineSeparator}" +
            "      super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, initialise(${lineSeparator}" +
            "      currentTokenVal, expectedTokenSequencesVal, tokenImageVal)));${lineSeparator}" +
            "      this.currentToken = currentTokenVal;${lineSeparator}" +
            "      this.expectedTokenSequences = expectedTokenSequencesVal;${lineSeparator}" +
            "      this.tokenImage = tokenImageVal;${lineSeparator}" +
            "  }",
        flags: "gm",
        byline: "false")
    ant.replaceregexp(file: new File(outputDir, "ParseException.java"),
        match: "^  public ParseException\\(String message.*\$(\\s\\s[^}].*\\n)*  \\}",
        replace: "  public ParseException(Message message) {${lineSeparator}" +
            "    super(message);${lineSeparator}" +
            "  }",
        flags: "gm",
        byline: "false")
    ant.replaceregexp(file: new File(outputDir, "ParseException.java"),
        match: "^  public ParseException\\(\\).*\$(\\s\\s[^}].*\\n)*  \\}",
        replace: "  public ParseException() {${lineSeparator}" +
            "    super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, \"Error\"));${lineSeparator}" +
            "  }",
        flags: "gm",
        byline: "false")
    ant.replaceregexp(file: new File(outputDir, "ParseException.java"),
        match: "^  public String getMessage\\(\\).*\$(\\s\\s\\s\\s[^}].*\n)*    \\}",
        replace: "  private static String initialise(Token currentToken, int[][] expectedTokenSequences, String[] tokenImage) {${lineSeparator}" +
            "String eol = System.getProperty(&quot;lineSeparator&quot;, &quot;\n&quot;);",
        flags: "gm",
        byline: "false")
    ant.replaceregexp(file: new File(outputDir, "ParseException.java"),
        match: "\\s*protected String add_escapes.*",
        replace: "  static private String add_escapes(String str) {",
        flags: "g",
        byline: "true")
  }
}


def doCleanUpAfter(File outputDir) {
  String lineSeparator = System.lineSeparator()
  // Remove debug stream (violates forbidden-apis)
  ant.replaceregexp(match: "/\\*\\* Debug output.*?Set debug output.*?ds; }", replace: '', flags: 's', encoding: 'UTF-8') {
    ant.fileset(dir: outputDir.getAbsolutePath(), includes: "*TokenManager.java")
  }

  ant.replace(token: "(int)(curChar >> 8);", value: "curChar >> 8;", encoding: "UTF-8") {
    ant.fileset(dir: outputDir.getAbsolutePath(), includes: "*TokenManager.java")
  }
  // This is very clumsy, but these are unused imports that are necessary other generated files
  [
      "import java.util.Vector;",
      "import org.apache.lucene.queryparser.flexible.messages.Message;",
      "import org.apache.lucene.queryparser.flexible.messages.MessageImpl;",
      "import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;",
      "import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;",
      "import org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode;",
      "import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;",
      "import org.apache.lucene.queryparser.flexible.core.nodes.BoostQueryNode;",
      "import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;",
      "import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;",
      "import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;",
      "import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;",
      "import org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode;",
      "import org.apache.lucene.queryparser.flexible.standard.nodes.RegexpQueryNode;",
      "import org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode;",
      "import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;",
      "import org.apache.lucene.queryparser.flexible.core.nodes.QuotedFieldQueryNode;",
      "import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;",
      "import org.apache.lucene.queryparser.flexible.standard.nodes.TermRangeQueryNode;",
      "import java.io.StringReader;",
      "import java.util.ArrayList;",
      "import java.util.Arrays;",
      "import java.util.HashSet;",
      "import java.util.List;",
      "import java.util.Locale;",
      "import java.util.Set;",
      "import org.apache.lucene.analysis.Analyzer;",
      "import org.apache.lucene.document.DateTools;",
      "import org.apache.lucene.search.BooleanClause;",
      "import org.apache.lucene.search.Query;",
      "import org.apache.lucene.search.TermRangeQuery;",
      "import org.apache.lucene.analysis.TokenStream;",
      "import org.apache.lucene.queryparser.surround.query.SrndQuery;",
      "import org.apache.lucene.queryparser.surround.query.FieldsQuery;",
      "import org.apache.lucene.queryparser.surround.query.OrQuery;",
      "import org.apache.lucene.queryparser.surround.query.AndQuery;",
      "import org.apache.lucene.queryparser.surround.query.NotQuery;",
      "import org.apache.lucene.queryparser.surround.query.DistanceQuery;",
      "import org.apache.lucene.queryparser.surround.query.SrndTermQuery;",
      "import org.apache.lucene.queryparser.surround.query.SrndPrefixQuery;",
      "import org.apache.lucene.queryparser.surround.query.SrndTruncQuery;"
  ].each {
    ant.replaceregexp(match: "${it}.*${lineSeparator}", replace: "", encoding: "UTF-8") {
      ant.fileset(dir: outputDir.getAbsolutePath(), includes: "*TokenManager.java")
    }
  }

  [
      "import org.apache.lucene.analysis.TokenStream;",
  ].each {
    ant.replaceregexp(match: "${it}.*${lineSeparator}", replace: "", encoding: "UTF-8") {
      ant.fileset(dir: outputDir.getAbsolutePath(), includes: "QueryParser.java")
    }
  }
  // StringBuffer -> StringBuilder
  ant.replace(token: "StringBuffer", value: "StringBuilder", encoding: "UTF-8") {
    ant.fileset(dir: outputDir.getAbsolutePath(), includes: "ParseException.java TokenMgrError.java")
  }
  ant.replace(token: "implemetation", value: "implementation", encoding: "UTF-8") {
    ant.fileset(dir: outputDir.getAbsolutePath(), includes: "CharStream.java")
  }

  // If nothing else, adds a newline to the end of the file if it doesn't already have one
  ant.fixcrlf(srcdir: outputDir.getAbsolutePath(), includes: '*.java', encoding: 'UTF-8') {
    ant.containsregexp(expression: 'Generated.*By.*JavaCC')
  }
}

// Try to remove all warnings and the like.
task cleanUpAfter(dependsOn: [runJavaccQueryParser, runJavaccSurround, runJavaccFlexible]) {
  doLast {
    println "Cleaning up warnings"
    conf.each { key, val ->
      doCleanUpAfter(val["outputDir"])
    }
  }
}

task regenerate {
  group = 'Build Regenerate'
  description = "Regenerates various generated src files javacc"
  dependsOn cleanOldGeneratedFiles, runJavaccQueryParser, runJavaccSurround, runJavaccFlexible, cleanUpAfter
}

