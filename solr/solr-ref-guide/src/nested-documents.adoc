= Nested Child Documents
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

Solr supports indexing nested documents such as a blog post parent document and comments as child documents -- or products as parent documents and sizes, colors, or other variations as child documents. +
The parent with all children is referred to as a "block" and it explains some of the nomenclature of related features.
At query time, the <<other-parsers.adoc#block-join-query-parsers,Block Join Query Parsers>> can search these relationships,
 and the `<<transforming-result-documents.adoc#child-childdoctransformerfactory,[child]>>` Document Transformer can attach child documents to the result documents.
In terms of performance, indexing the relationships between documents usually yields much faster queries than an equivalent "query time join",
 since the relationships are already stored in the index and do not need to be computed.
However, nested documents are less flexible than query time joins as it imposes rules that some applications may not be able to accept.

[NOTE]
====
A big limitation is that the whole block of parent-children documents must be updated or deleted together, not separately.
In other words, even if a single child document or the parent document is changed, the whole block of parent-child documents must be indexed together.
_Solr does not enforce this rule_; if it's violated, you may get sporadic query failures or incorrect results.
====

== Indexing Nested Documents

Nested documents may be indexed via either the XML or JSON data syntax, and is also supported by <<using-solrj.adoc#using-solrj,SolrJ>> with javabin.

=== Schema Configuration

 * The schema must include indexed field `\_root_`. The value of that field is populated automatically and is the same for all documents in the block, regardless of the inheritance depth. The ID of the top document in every nested hierarchy is populated in this field. +
 `<field name="\_root_" type="string" indexed="true" stored="false" docValues="false" />`
 * `\_nest_path_` is used to store the path of the document in the hierarchy. This field is optional. +
 `<fieldType name="\_nest_path_" class="solr.NestPathField" />
  <field name="\_nest_path_" type="_nest_path_" />`
 * `\_nest_parent_` is used to store the `ID` of the parent in the previous level. This field is optional. +
 `<field name="\_nest_parent_" type="string" indexed="true" stored="true"/>`
 * Nested documents are very much documents in their own right even if certain nested documents hold different information from the parent.
   Therefore:
 ** the schema must be able to represent the fields of any document
 ** it may be infeasible to use `required`
 ** even child documents need a unique `ID`
 * If you associate a child document as a field (e.g., comment), that field need not be defined in the schema, and probably
    shouldn't be as it would be confusing.  There is no child document field type.

== Rudimentary Root-only schemas

 * These schemas do not contain any other nested related fields apart from `\_root_`. +
   In this mode relationship types(field names) between parents and their children are not saved. +
   In this case <<nested-documents.adoc#child-doc-transformer,[child]>> transformer returns all children under the `\_childDocuments_` field.
 * Typically you should have a field that differentiates a root doc from any nested children. However this isn't strictly necessary; so long as it's possible to write a query that can select only root documents somehow. Such a query is needed for the <<other-parsers.adoc#block-join-query-parsers,block join query parsers>> and <<nested-documents.adoc#child-doc-transformer,[child]>> doc transformer to function.

=== XML Examples

For example, here are two documents and their child documents.
It illustrates two styles of adding child documents; the first is associated via a field "comment" (preferred),
and the second is done in the classic way now referred to as an "anonymous" or "unlabelled" child document.
This field label relationship is available to the URP chain in Solr but is ultimately discarded.
Solr 8 will save the relationship.

[source,xml]
----
<add>
  <doc>
    <field name="ID">1</field>
    <field name="title">Solr adds block join support</field>
    <field name="content_type">parentDocument</field>
    <field name="content">
      <doc>
        <field name="ID">2</field>
        <field name="comments">SolrCloud supports it too!</field>
      </doc>
    </field>
  </doc>
  <doc>
    <field name="ID">3</field>
    <field name="title">New Lucene and Solr release is out</field>
    <field name="content_type">parentDocument</field>
    <doc>
      <field name="ID">4</field>
      <field name="comments">Lots of new features</field>
    </doc>
  </doc>
</add>
----

In this example, we have indexed the parent documents with the field `content_type`, which has the value "parentDocument".
We could have also used a boolean field, such as `isParent`, with a value of "true", or any other similar approach.

=== JSON Examples

This example is equivalent to the XML example above.
Again, the field labelled relationship is preferred.
The labelled relationship here is one child document but could have been wrapped in array brackets.
For the anonymous relationship, note the special `\_childDocuments_` key whose contents must be an array of child documents.

[source,json]
----
[
  {
    "ID": "1",
    "title": "Solr adds block join support",
    "content_type": "parentDocument",
    "comments": [{
        "ID": "2",
        "content": "SolrCloud supports it too!"
      },
      {
        "ID": "3",
        "content": "New filter syntax"
      }
    ]
  },
  {
    "ID": "4",
    "title": "New Lucene and Solr release is out",
    "content_type": "parentDocument",
    "_childDocuments_": [
      {
        "ID": "5",
        "comments": "Lots of new features"
      }
    ]
  }
]
----

.Root-Only Mode
[NOTE]
 In Root-only schemas, these two documents will result in the same docs being indexed (Root-only schemas do not honor nested relationships).
 When queried, child docs will be appended to _childDocuments_ key.

== Searching Nested Documents

 * `<<nested-documents.adoc#child-doc-transformer,[child]>>` Document Transformer
 * <<nested-documents.adoc#children-query-parser,Block Join Children Query Parser>>
 * <<nested-documents.adoc#parents-query-parser,Block Join Parent Query Parser>>
 * <<nested-documents.adoc#combining-block-join-query-parsers-with-child-doc-transformer,Advanced Queries>>
 * <<blockjoin-faceting#blockjoin-faceting, Faceting using nested documents(blockChildren and blockParents)>>

=== Query Examples

For the upcoming examples, assume the following documents have been indexed:

[source,json]
----
[
  {
    "ID": "1",
    "title": "Cooking Recommendations",
    "tags": ["cooking", "meetup"],
    "posts": [{
        "ID": "2",
        "title": "Cookies",
        "comments": [{
            "ID": "3",
            "content": "Lovely recipe"
          },
          {
            "ID": "4",
            "content": "A-"
          }
        ]
      },
      {
        "ID": "5",
        "title": "Cakes"
      }
    ]
  },
  {
    "ID": "6",
    "title": "For Hire",
    "tags": ["professional", "jobs"],
    "posts": [{
        "ID": "7",
        "title": "Search Engineer",
        "comments": [{
           "ID": "8",
           "content": "I am interested"
         },
         {
           "ID": "9",
           "content": "How large is the team?"
         }
        ]
      },
      {
        "ID": "10",
        "title": "Low level Engineer"
      }
    ]
  }
]
----

==== Child Doc Transformer

Can be used enrich query results with the documents' descendants. +
For a detailed explanation of this transformer, see the section <<transforming-result-documents.adoc#child-childdoctransformerfactory, [child] - ChildDocTransformerFactory>>.

For example, let us examine this query:
`q=ID:1,
fl=ID,[child childFilter=/comments/content:recipe]`. +
The Child Doc Transformer can be used to enrich matching docs with comments that match a particular filter. +
In this particular query, the child Filter will only match the first comment of doc(ID:1),
therefore only that particular comment will be appended to the result.

[source,json]
----
 { "response":{"numFound":1,"start":0,"docs":[
       {
           "ID": "1",
           "title": "Cooking Recommendations",
           "tags": ["cooking", "meetup"],
           "posts": [{
               "ID": "2",
               "title": "Cookies",
               "comments": [{
                   "ID": "3",
                   "content": "Lovely recipe"
               }]
             }]
        }]
    }
 }
----

==== Children Query Parser

Can be used to retrieve children of a matching document. +
For a detailed explanation of this parser, see the section <<other-parsers.adoc#block-join-children-query-parser, Block Join Children Query Parser>>.

For example, let us examine this query:
`q={!child of='_nest_path_:/posts}content:"Search Engineer"`. +
The `'of'` filter returns all posts. This is used to filter out all documents in a particular path of the hierarchy(all parents).
The second part of the query is a filter for some parents, which we wish to return their children. +
In this example, all comments of posts which had "Search Engineer in their `content` field will be returned.

[source,json]
----
     { "response":{"numFound":2,"start":0,"docs":[
           {
              "ID": "8",
              "content": "I am interested"
           },
           {
              "ID": "9",
              "content": "How large is the team?"
           }
        ]}
     }
----

==== Parents Query Parser

Can be used to retrieve parents of a child document. +
For a detailed explanation of this parser, see the section <<other-parsers.adoc#block-join-parent-query-parser,Block Join Parent Query Parser>>.

For example, let us examine this query:
`q={!parent which='-_nest_path_:* \*:*'}title:"Search Engineer"`. +
The `'which'` filter returns all root documents.
The second part of this query is a filter to match some child documents.
This query returns the parent at the root(since all parents filter returns root documents) of each
matching child document. In this case, all child documents which had `Search Engineer` in their `title` field.

[source,json]
----
  { "response":{"numFound":1,"start":0,"docs":[{
         "ID": "6",
         "title": "For Hire",
         "tags": ["professional", "jobs"]
         }
    ]}
  }
----

==== Combining Block Join Query Parsers with Child Doc Transformer

The combination of these two features enable seamless creation of powerful queries. +
For example, querying posts which are under a page tagged as a job, contain the words "Search Engineer".
The comments for matching posts can also be fetched, all done in a single Solr Query.

For example, let us examine this query:
`q=+{!child of='-\_nest_path_:* \*:*'}+tags:"jobs" &fl=*,[child]
&fq=\_nest_path_:/posts`. +
This query returns all posts and their comments, which had "Search Engineer" in their title,
and are indexed under a page tagged with "jobs".
The comments are appended to the matching posts, since the ChildDocTransformer is specified under the `fl` parameter.

[source,json]
----
  { "response":{"numFound":1,"start":0,"docs":[
        {
          "ID": "7",
          "title": "Search Engineer",
          "comments": [{
             "ID": "8",
             "content": "I am interested"
           },
           {
             "ID": "9",
             "content": "How large is the team?"
           }
          ]
        },
        {
          "ID": "10",
          "title": "Low level Engineer"
        }]
     }
  }
----

