= Searching Nested Child Documents
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

This section exposes potential techniques which can be used for searching deeply nested documents,
show casing how more complex queries can be constructed using some of Solr's query parsers and Doc Transformers.
These features require `\_root_` and `\_nest_path_` to be declared in the schema. +
Please refer to the <<indexing-nested-documents.adoc#indexing-nested-documents, Indexing Nested Documents>>
section for more details about schema and index configuration.


[NOTE]
This section does not show case faceting on nested documents. For nested document faceting, please refer to the
<<json-facet-api#uniqueblock-and-block-join-counts, Block Join Facet Counts>> section.

== Query Examples

For the upcoming examples, we'll assume an index containing the same documents covered in <<indexing-nested-documents#example-indexing-syntax,Indexing Nested Documents>>:

include::indexing-nested-documents.adoc[tag=sample-indexing-deeply-nested-documents]

=== Child Doc Transformer

By default, documents that match a query do not include any of thir nested children in the response.  The `[child]` Doc Transformer Can be used enrich query results with the documents' descendants.

For a detailed explanation of this transformer, and specifics on it's syntax & limitations, please refer to the section <<transforming-result-documents.adoc#child-childdoctransformerfactory, [child] - ChildDocTransformerFactory>>.

A simple query matching all documents with a description that includes "staplers":

[source,bash]
----
$ curl 'http://localhost:8983/solr/gettingstarted/select?omitHeader=true&q=description_t:staplers'
{
  "response":{"numFound":1,"start":0,"maxScore":0.30136836,"numFoundExact":true,"docs":[
      {
        "id":"P11!prod",
        "name_s":"Swingline Stapler",
        "description_t":"The Cadillac of office staplers ...",
        "_version_":1672933224035123200}]
  }}
----

The same query with the addition of the `[child]` transformer is shown below.  Note that the `numFound` has not changed, we are still matching the same set of documents, but when returning those documents the nested children are also returned as psuedo-fields.

[source,bash]
----
$ curl 'http://localhost:8983/solr/gettingstarted/select?omitHeader=true&q=description_t:staplers&fl=*,[child]'
{
  "response":{"numFound":1,"start":0,"maxScore":0.30136836,"numFoundExact":true,"docs":[
      {
        "id":"P11!prod",
        "name_s":"Swingline Stapler",
        "description_t":"The Cadillac of office staplers ...",
        "_version_":1672933224035123200,
        "skus":[
          {
            "id":"P11!S21",
            "color_s":"RED",
            "price_i":42,
            "_version_":1672933224035123200,
            "docs":[
              {
                "id":"P11!D41",
                "name_s":"Red Swingline Brochure",
                "content_t":"...",
                "_version_":1672933224035123200}]},
          
          {
            "id":"P11!S31",
            "color_s":"BLACK",
            "price_i":3,
            "_version_":1672933224035123200}],
        "docs":[
          {
            "id":"P11!D51",
            "name_s":"Quick Reference Guide",
            "content_t":"How to use your stapler ...",
            "_version_":1672933224035123200},
          
          {
            "id":"P11!D61",
            "name_s":"Warranty Details",
            "content_t":"... lifetime garuntee ...",
            "_version_":1672933224035123200}]}]
  }}
----


=== Child Query Parser

The `{!child}` query parser can be used to search for the _descendent_ documents of parent documents matching a wrapped query. For a detailed explanation of this parser, see the section <<other-parsers.adoc#block-join-children-query-parser, Block Join Children Query Parser>>.

Let's consider again the `description_t:staplers` query used above -- if we wrap that query in a `{!child}` query parser then instead of "matching" & returning the product level documents, we instead match all of the _descendent_ child documents of the original query:

[source,bash]
----
$ curl --globoff 'http://localhost:8983/solr/gettingstarted/select?omitHeader=true&q={!child+of="*:*+-_nest_path_:*"}description_t:staplers'
{
  "response":{"numFound":5,"start":0,"maxScore":0.30136836,"numFoundExact":true,"docs":[
      {
        "id":"P11!D41",
        "name_s":"Red Swingline Brochure",
        "content_t":"...",
        "_version_":1672933224035123200},
      {
        "id":"P11!S21",
        "color_s":"RED",
        "price_i":42,
        "_version_":1672933224035123200},
      {
        "id":"P11!S31",
        "color_s":"BLACK",
        "price_i":3,
        "_version_":1672933224035123200},
      {
        "id":"P11!D51",
        "name_s":"Quick Reference Guide",
        "content_t":"How to use your stapler ...",
        "_version_":1672933224035123200},
      {
        "id":"P11!D61",
        "name_s":"Warranty Details",
        "content_t":"... lifetime garuntee ...",
        "_version_":1672933224035123200}]
  }}
----

NOTE: The `of` local param is neccessary to tell the `{!child}` parser the set of _all_ "ancestor" documents to consider when looking for matching children.  In this example we've used `\*:* -\_nest_path_:*` to indicate we want to consider all documents which don't have a nest path field -- ie: all "root" level document.  When dealing with multiple levels of nested documents, it can be very tricky to define a correct `of` param -- see the <<other-parsers.adoc#block-join-children-query-parser,`{!child}` parser section>> for details.

=== Parent Query Parser

The inverse of the `{!child}` query parser is the `{!parent}` query parser, which let's you search for the _ancestor_ documents of some child documents matching a wrapped query.  For a detailed explanation of this parser, see the section <<other-parsers.adoc#block-join-parent-query-parser,Block Join Parent Query Parser>>.

Let's first consider this example of searching for all "sku" type documents that have a color of "RED"...

[source,bash]
----
$ curl 'http://localhost:8983/solr/gettingstarted/select?omitHeader=true&q=color_s:RED'
{
  "response":{"numFound":2,"start":0,"maxScore":0.2449984,"numFoundExact":true,"docs":[
      {
        "id":"P11!S21",
        "color_s":"RED",
        "price_i":42,
        "_version_":1672933224035123200},
      {
        "id":"P22!S22",
        "color_s":"RED",
        "price_i":89,
        "_version_":1672933224436727808}]
  }}
----

We can wrap that query in a `{!parent}` query to return the details of all products that have "RED" skus...

[source,bash]
----
$ curl --globoff 'http://localhost:8983/solr/gettingstarted/select?omitHeader=true&q={!parent+which="*:*+-_nest_path_:*"}color_s:RED'
{
  "response":{"numFound":2,"start":0,"maxScore":1.4E-45,"numFoundExact":true,"docs":[
      {
        "id":"P11!prod",
        "name_s":"Swingline Stapler",
        "description_t":"The Cadillac of office staplers ...",
        "_version_":1672933224035123200},
      {
        "id":"P22!prod",
        "name_s":"Mont Blanc Fountain Pen",
        "description_t":"A Premium Writing Instrument ...",
        "_version_":1672933224436727808}]
  }}
----


NOTE: The `which` local param of the `{!parent}` parser serves the same purpse as the `{!child}` parser's `of` param: to define the set of _all_ "ancestor" documents to consider for matching based on their children.  In this example we've again used `\*:* -\_nest_path_:*` to indicate we want to consider all documents which don't have a nest path field -- ie: all "root" level document.  When dealing with multiple levels of nested documents, it can be very tricky to define a correct `which` param -- see the <<other-parsers.adoc#block-join-parent-query-parser,`{!parent}` parser section>> for details.



=== Combining Block Join Query Parsers with Child Doc Transformer

The combination of these two parsers with the `[child] transformer enables seamless creation of very powerful queries.

Here for example is a query where:

* the (sku) documents returned must have a color of "RED"
* the (sku) docments returned must be the descendents of root level (product) documents which have:
** immediate child "docs" documents which have:
*** "lifetime garuntee" in their content
* each return (sku) document also includes any descendent (docs) documents it has

[source,bash]
----
$ curl --globoff 'http://localhost:8983/solr/gettingstarted/select?omitHeader=true&fq=color_s:RED&q={!child+of="*:*+-_nest_path_:*"+filters=$parent_fq}&parent_fq={!parent+which="*:*+-_nest_path_:*"}_nest_path_:"/docs"+AND+content_t:"lifetime+garuntee"&fl=*,[child]'
{
  "response":{"numFound":1,"start":0,"maxScore":1.4E-45,"numFoundExact":true,"docs":[
      {
        "id":"P11!S21",
        "color_s":"RED",
        "price_i":42,
        "_version_":1672933224035123200,
        "docs":[
          {
            "id":"P11!D41",
            "name_s":"Red Swingline Brochure",
            "content_t":"...",
            "_version_":1672933224035123200}]}]
  }}
----
