#!/usr/bin/env bash
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# CONTROLLING STARTUP:
#
# Use solr -help to see available command-line options. In addition
# to passing command-line options, this script looks for an include
# file named solr.in.sh to set environment variables. Specifically, 
# the following locations are searched in this order:
#
# ./
# $HOME/.solr.in.sh
# /usr/share/solr
# /usr/local/share/solr
# /var/solr/
# /opt/solr
#
# Another option is to specify the full path to the include file in the
# environment. For example:
#
#   $ SOLR_INCLUDE=/path/to/solr.in.sh solr start
#
# Note: This is particularly handy for running multiple instances on a 
# single installation, or for quick tests.
#
# Finally, developers and enthusiasts who frequently run from an SVN 
# checkout, and do not want to locally modify bin/solr.in.sh, can put
# a customized include file at ~/.solr.in.sh.
#
# If you would rather configure startup entirely from the environment, you
# can disable the include by exporting an empty SOLR_INCLUDE, or by 
# ensuring that no include files exist in the aforementioned search list.

SOLR_SCRIPT="$0"
verbose=false
THIS_OS=`uname -s`
hasLsof=$(which lsof)
stop_all=false

# for now, we don't support running this script from cygwin due to problems
# like not having lsof, ps auxww, curl, and awkward directory handling
if [ "${THIS_OS:0:6}" == "CYGWIN" ]; then
  echo -e "This script does not support cygwin due to severe limitations and lack of adherence\nto BASH standards, such as lack of lsof, curl, and ps options.\n\nPlease use the native solr.cmd script on Windows!"
  exit 1
fi

# Resolve symlinks to this script
while [ -h "$SOLR_SCRIPT" ] ; do
  ls=`ls -ld "$SOLR_SCRIPT"`
  # Drop everything prior to ->
  link=`expr "$ls" : '.*-> \(.*\)$'`
  if expr "$link" : '/.*' > /dev/null; then
    SOLR_SCRIPT="$link"
  else
    SOLR_SCRIPT=`dirname "$SOLR_SCRIPT"`/"$link"
  fi
done

SOLR_TIP=`dirname "$SOLR_SCRIPT"`/..
SOLR_TIP=`cd "$SOLR_TIP"; pwd`
DEFAULT_SERVER_DIR=$SOLR_TIP/server

# If an include wasn't specified in the environment, then search for one...
if [ -z "$SOLR_INCLUDE" ]; then
  # Locations (in order) to use when searching for an include file.
  for include in "`dirname "$0"`/solr.in.sh" \
               "$HOME/.solr.in.sh" \
               /usr/share/solr/solr.in.sh \
               /usr/local/share/solr/solr.in.sh \
               /var/solr/solr.in.sh \
               /opt/solr/solr.in.sh; do
    if [ -r "$include" ]; then
        . "$include"
        break
    fi
  done
elif [ -r "$SOLR_INCLUDE" ]; then
  . "$SOLR_INCLUDE"
fi

if [ -z "$SOLR_PID_DIR" ]; then
  SOLR_PID_DIR=$SOLR_TIP/bin
fi

if [ -n "$SOLR_JAVA_HOME" ]; then
  JAVA=$SOLR_JAVA_HOME/bin/java
elif [ -n "$JAVA_HOME" ]; then
  for java in "$JAVA_HOME"/bin/amd64/java "$JAVA_HOME"/bin/java; do
    if [ -x "$java" ]; then
      JAVA="$java"
      break
    fi
  done
else
  JAVA=java
fi

# test that Java exists and is executable on this server
$JAVA -version >/dev/null 2>&1 || { echo >&2 "Java is required to run Solr! Please install Java 7 or 8 before running this script."; exit 1; }

function print_usage() {
  CMD="$1"
  ERROR_MSG="$2"
    
  if [ "$ERROR_MSG" != "" ]; then
    echo -e "\nERROR: $ERROR_MSG\n"
  fi
  
  if [ -z "$CMD" ]; then
    echo ""
    echo "Usage: solr COMMAND OPTIONS"
    echo "       where COMMAND is one of: start, stop, restart, status, healthcheck, create_core, create_collection"
    echo ""
    echo "  Standalone server example (start Solr running in the background on port 8984):"
    echo ""
    echo "    ./solr start -p 8984"
    echo ""
    echo "  SolrCloud example (start Solr running in SolrCloud mode using localhost:2181 to connect to ZooKeeper, with 1g max heap size and remote Java debug options enabled):"
    echo ""
    echo "    ./solr start -c -m 1g -z localhost:2181 -a \"-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\""
    echo ""
    echo "Pass -help after any COMMAND to see command-specific usage information,"
    echo "  such as:    ./solr start -help or ./solr stop -help"
    echo ""
  elif [[ "$CMD" == "start" || "$CMD" == "restart" ]]; then
    echo ""
    echo "Usage: solr $CMD [-f] [-c] [-h hostname] [-p port] [-d directory] [-z zkHost] [-m memory] [-e example] [-s solr.solr.home] [-a \"additional-options\"] [-V]"
    echo ""
    echo "  -f            Start Solr in foreground; default starts Solr in the background"
    echo "                  and sends stdout / stderr to solr-PORT-console.log"
    echo ""
    echo "  -c or -cloud  Start Solr in SolrCloud mode; if -z not supplied, an embedded ZooKeeper"
    echo "                  instance is started on Solr port+1000, such as 9983 if Solr is bound to 8983"
    echo ""
    echo "  -h <host>     Specify the hostname for this Solr instance"
    echo ""
    echo "  -p <port>     Specify the port to start the Solr HTTP listener on; default is 8983"
    echo "                  The specified port (SOLR_PORT) will also be used to determine the stop port"
    echo "                  STOP_PORT=(\$SOLR_PORT-1000) and JMX RMI listen port RMI_PORT=(1\$SOLR_PORT). "
    echo "                  For instance, if you set -p 8985, then the STOP_PORT=7985 and RMI_PORT=18985"
    echo ""
    echo "  -d <dir>      Specify the Solr server directory; defaults to server"
    echo ""
    echo "  -z <zkHost>   ZooKeeper connection string; only used when running in SolrCloud mode using -c"
    echo "                   To launch an embedded ZooKeeper instance, don't pass this parameter."
    echo ""
    echo "  -m <memory>   Sets the min (-Xms) and max (-Xmx) heap size for the JVM, such as: -m 4g"
    echo "                  results in: -Xms4g -Xmx4g; by default, this script sets the heap size to 512m"
    echo ""
    echo "  -s <dir>      Sets the solr.solr.home system property; Solr will create core directories under"
    echo "                  this directory. This allows you to run multiple Solr instances on the same host"
    echo "                  while reusing the same server directory set using the -d parameter. If set, the"
    echo "                  specified directory should contain a solr.xml file. The default value is server/solr."
    echo "                  This parameter is ignored when running examples (-e), as the solr.solr.home depends"
    echo "                  on which example is run."
    echo ""
    echo "  -e <example>  Name of the example to run; available examples:"
    echo "      cloud:         SolrCloud example"
    echo "      techproducts:  Comprehensive example illustrating many of Solr's core capabilities"
    echo "      dih:           Data Import Handler"
    echo "      schemaless:    Schema-less example"
    echo ""
    echo "  -a            Additional parameters to pass to the JVM when starting Solr, such as to setup"
    echo "                  Java debug options. For example, to enable a Java debugger to attach to the Solr JVM"
    echo "                  you could pass: -a \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=18983\""
    echo "                  In most cases, you should wrap the additional parameters in double quotes."
    echo ""
    echo "  -noprompt     Don't prompt for input; accept all defaults when running examples that accept user input"
    echo ""
    echo "  -V            Verbose messages from this script"
    echo ""
  elif [ "$CMD" == "stop" ]; then
    echo ""
    echo "Usage: solr stop [-k key] [-p port] [-V]"
    echo ""
    echo "  -k <key>      Stop key; default is solrrocks"
    echo ""
    echo "  -p <port>     Specify the port the Solr HTTP listener is bound to"
    echo ""
    echo "  -all          Find and stop all running Solr servers on this host"
    echo ""
    echo "  NOTE: To see if any Solr servers are running, do: solr status"
    echo ""
  elif [ "$CMD" == "healthcheck" ]; then
    echo ""
    echo "Usage: solr healthcheck [-c collection] [-z zkHost]"
    echo ""
    echo "  -c <collection>  Collection to run healthcheck against."
    echo ""
    echo "  -z <zkHost>      ZooKeeper connection string; default is localhost:9983"
    echo ""
  elif [ "$CMD" == "status" ]; then
    echo ""
    echo "Usage: solr status"
    echo ""
    echo "  NOTE: This command will show the status of all running Solr servers"
    echo ""
  elif [ "$CMD" == "create_core" ]; then
    echo ""
    echo "Usage: solr create_core [-n name] [-c configset]"
    echo ""
    echo "  -n <name>       Name of core to create"
    echo ""
    echo "  -c <configset>  Name of configuration directory to use, built-in options are:"
    echo "      basic_configs: Minimal Solr configuration"
    echo "      data_driven_schema_configs: Managed schema with field-guessing support enabled"
    echo "      sample_techproducts_configs: Example configuration with many optional features enabled to"
    echo "         demonstrate the full power of Solr"
    echo "      If not specified, default is: data_driven_schema_configs"
    echo ""
    echo "      Alternatively, you can pass the path to your own configuration directory instead of using"
    echo "      one of the built-in configurations, such as: bin/solr create_core -n mycore -c /tmp/myconfig"
    echo ""
  elif [ "$CMD" == "create_collection" ]; then
    echo ""
    echo "Usage: solr create_collection [-n name] [-c configset] [-shards #] [-replicationFactor #]"
    echo ""
    echo "  -n <name>               Name of collection to create"
    echo ""
    echo "  -c <configset>          Name of configuration directory to use, built-in options are:"
    echo "      basic_configs: Minimal Solr configuration"
    echo "      data_driven_schema_configs: Managed schema with field-guessing support enabled"
    echo "      sample_techproducts_configs: Example configuration with many optional features enabled to"
    echo "         demonstrate the full power of Solr"
    echo "      If not specified, default is: data_driven_schema_configs"
    echo ""
    echo "      Alternatively, you can pass the path to your own configuration directory instead of using"
    echo "      one of the built-in configurations, such as: bin/solr create_collection -n mycoll -c /tmp/myconfig"
    echo ""
    echo "  -shards <#>             Number of shards to split the collection into; default is 1"
    echo ""
    echo "  -replicationFactor <#>  Number of copies of each document in the collection, default is 1 (no replication)"
    echo ""
    echo ""
  fi
} # end print_usage

# used to show the script is still alive when waiting on work to complete
function spinner() {
  local pid=$1
  local delay=0.5
  local spinstr='|/-\'
  while [ "$(ps aux | awk '{print $2}' | grep $pid)" ]; do
      local temp=${spinstr#?}
      printf " [%c]  " "$spinstr"
      local spinstr=$temp${spinstr%"$temp"}
      sleep $delay
      printf "\b\b\b\b\b\b"
  done
  printf "    \b\b\b\b"
}

# given a port, find the pid for a Solr process
function solr_pid_by_port() {
  THE_PORT="$1"
  if [ -e "$SOLR_PID_DIR/solr-$THE_PORT.pid" ]; then
    PID=`cat $SOLR_PID_DIR/solr-$THE_PORT.pid`
    CHECK_PID=`ps auxww | awk '{print $2}' | grep $PID | sort -r | tr -d ' '`
    if [ "$CHECK_PID" != "" ]; then
      local solrPID=$PID
    fi
  fi
  echo "$solrPID"
}

# extract the value of the -Djetty.port parameter from a running Solr process 
function jetty_port() {
  SOLR_PID="$1"
  SOLR_PROC=`ps auxww | grep $SOLR_PID | grep start.jar | grep jetty.port`      
  IFS=' ' read -a proc_args <<< "$SOLR_PROC"
  for arg in "${proc_args[@]}"
    do
      IFS='=' read -a pair <<< "$arg"
      if [ "${pair[0]}" == "-Djetty.port" ]; then
        local jetty_port="${pair[1]}"
        break
      fi
    done    
  echo "$jetty_port"
} # end jetty_port func

# run a Solr command-line tool using the SolrCLI class; 
# useful for doing cross-platform work from the command-line using Java
function run_tool() {
  
  # Extract the solr.war if it hasn't been done already (so we can access the SolrCLI class)
  if [[ -e $DEFAULT_SERVER_DIR/webapps/solr.war && ! -d "$DEFAULT_SERVER_DIR/solr-webapp/webapp" ]]; then
    (mkdir -p $DEFAULT_SERVER_DIR/solr-webapp/webapp && cd $DEFAULT_SERVER_DIR/solr-webapp/webapp && jar xf $DEFAULT_SERVER_DIR/webapps/solr.war)    
  fi
  
  "$JAVA" -Dlog4j.configuration=file:$DEFAULT_SERVER_DIR/scripts/cloud-scripts/log4j.properties \
    -classpath "$DEFAULT_SERVER_DIR/solr-webapp/webapp/WEB-INF/lib/*:$DEFAULT_SERVER_DIR/lib/ext/*" \
    org.apache.solr.util.SolrCLI $*

  return $?
} # end run_tool function

# get information about any Solr nodes running on this host
function get_info() {
  # first, see if Solr is running
  numSolrs=`find $SOLR_PID_DIR -name "solr-*.pid" -type f | wc -l | tr -d ' '`
  if [ "$numSolrs" != "0" ]; then
    echo -e "\nFound $numSolrs Solr nodes: "
    for PIDF in `find $SOLR_PID_DIR -name "solr-*.pid" -type f`
      do
        ID=`cat $PIDF`
        port=`jetty_port "$ID"`
        if [ "$port" != "" ]; then
          echo -e "\nSolr process $ID running on port $port"
          run_tool status -solr http://localhost:$port/solr
          echo ""
        else
          echo -e "\nSolr process $ID from $PIDF not found."
        fi
    done
  else
    # no pid files but check using ps just to be sure
    numSolrs=`ps auxww | grep start.jar | grep solr.solr.home | grep -v grep | wc -l | sed -e 's/^[ \t]*//'`
    if [ "$numSolrs" != "0" ]; then
      echo -e "\nFound $numSolrs Solr nodes: "
      for ID in `ps auxww | grep start.jar | grep solr.solr.home | grep -v grep | awk '{print $2}' | sort -r`
        do
          port=`jetty_port "$ID"`
          if [ "$port" != "" ]; then
            echo ""
            echo "Solr process $ID running on port $port"
            run_tool status -solr http://localhost:$port/solr
            echo ""
          fi
      done
    else
      echo -e "\nNo Solr nodes are running.\n"
    fi
  fi
  
} # end get_info

# tries to gracefully stop Solr using the Jetty 
# stop command and if that fails, then uses kill -9
function stop_solr() {

  DIR="$1"
  SOLR_PORT="$2"
  STOP_PORT=`expr $SOLR_PORT - 1000`
  STOP_KEY="$3"
  SOLR_PID="$4"

  if [ "$SOLR_PID" != "" ]; then
    echo -e "Sending stop command to Solr running on port $SOLR_PORT ... waiting 5 seconds to allow Jetty process $SOLR_PID to stop gracefully."
    $JAVA -jar $DIR/start.jar STOP.PORT=$STOP_PORT STOP.KEY=$STOP_KEY --stop || true
    (sleep 5) &
    spinner $!
    rm -f $SOLR_PID_DIR/solr-$SOLR_PORT.pid
  else
    echo -e "No Solr nodes found to stop."
    exit 0
  fi

  CHECK_PID=`ps auxww | awk '{print $2}' | grep $SOLR_PID | sort -r | tr -d ' '`
  if [ "$CHECK_PID" != "" ]; then
    echo -e "Solr process $SOLR_PID is still running; forcefully killing it now."
    kill -9 $SOLR_PID
    echo "Killed process $SOLR_PID"
    rm -f $SOLR_PID_DIR/solr-$SOLR_PORT.pid
    sleep 1
  fi

  CHECK_PID=`ps auxww | awk '{print $2}' | grep $SOLR_PID | sort -r | tr -d ' '`
  if [ "$CHECK_PID" != "" ]; then
    echo "ERROR: Failed to kill previous Solr Java process $SOLR_PID ... script fails."
    exit 1
  fi
} # end stop_solr

if [ $# -eq 1 ]; then
  case $1 in
    -help|-usage)
        print_usage ""
        exit
    ;;
    -info|-i|status)
        get_info
        exit
    ;;
  esac
fi

if [ $# -gt 0 ]; then
  # if first arg starts with a dash (and it's not -help or -info), 
  # then assume they are starting Solr, such as: solr -f
  if [[ $1 == -* ]]; then
    SCRIPT_CMD="start"
  else
    SCRIPT_CMD=$1
    shift
  fi
else
  # no args - just show usage and exit
  print_usage ""
  exit  
fi

if [ "$SCRIPT_CMD" == "status" ]; then
  # hacky - the script hits this if the user passes additional args with the status command,
  # which is not supported but also not worth complaining about either
  get_info
  exit
fi

# run a healthcheck and exit if requested
if [ "$SCRIPT_CMD" == "healthcheck" ]; then

  if [ $# -gt 0 ]; then
    while true; do  
      case $1 in
          -c|-collection)
              if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
                print_usage "$SCRIPT_CMD" "Collection name is required when using the $1 option!"
                exit 1
              fi
              HEALTHCHECK_COLLECTION=$2
              shift 2
          ;;
          -z|-zkhost)          
              if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
                print_usage "$SCRIPT_CMD" "ZooKeepeer connection string is required when using the $1 option!"
                exit 1
              fi
              ZK_HOST="$2"
              shift 2
          ;;
          -help|-usage)
              print_usage "$SCRIPT_CMD"           
              exit 0
          ;;
          --)
              shift
              break
          ;;
          *)
              if [ "$1" != "" ]; then            
                print_usage "$SCRIPT_CMD" "Unrecognized or misplaced argument: $1!"
                exit 1
              else
                break # out-of-args, stop looping
              fi 
          ;;
      esac
    done
  fi
  
  if [ -z "$ZK_HOST" ]; then
    ZK_HOST=localhost:9983
  fi
  
  if [ -z "$HEALTHCHECK_COLLECTION" ]; then
    echo "collection parameter is required!"
    print_usage "healthcheck"
    exit 1  
  fi
    
  run_tool healthcheck -zkHost $ZK_HOST -collection $HEALTHCHECK_COLLECTION
    
  exit $?
fi

# create a core or collection
if [[ "$SCRIPT_CMD" == "create_core" || "$SCRIPT_CMD" == "create_collection" ]]; then

  CREATE_TYPE=collection
  CREATE_NUM_SHARDS=1
  CREATE_REPFACT=1
  if [ "$SCRIPT_CMD" == "create_core" ]; then
    CREATE_TYPE=core
  fi

  if [ $# -gt 0 ]; then
    while true; do
      case $1 in
          -n|-name)
              if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
                print_usage "$SCRIPT_CMD" "$CREATE_TYPE name is required when using the $1 option!"
                exit 1
              fi
              CREATE_NAME=$2
              shift 2
          ;;
          -c|-configset)
              if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
                print_usage "$SCRIPT_CMD" "Configset name is required when using the $1 option!"
                exit 1
              fi
              CREATE_CONFIGSET="$2"
              shift 2
          ;;
          -s|-shards)
              if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
                print_usage "$SCRIPT_CMD" "Shard count is required when using the $1 option!"
                exit 1
              fi
              CREATE_NUM_SHARDS="$2"
              shift 2
          ;;
          -rf|-replicationFactor)
              if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
                print_usage "$SCRIPT_CMD" "Replication factor is required when using the $1 option!"
                exit 1
              fi
              CREATE_REPFACT="$2"
              shift 2
          ;;
          -p|-port)
              if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
                print_usage "$SCRIPT_CMD" "Solr port is required when using the $1 option!"
                exit 1
              fi
              CREATE_PORT="$2"
              shift 2
          ;;
          -help|-usage)
              print_usage "$SCRIPT_CMD"
              exit 0
          ;;
          --)
              shift
              break
          ;;
          *)
              if [ "$1" != "" ]; then
                print_usage "$SCRIPT_CMD" "Unrecognized or misplaced argument: $1!"
                exit 1
              else
                break # out-of-args, stop looping
              fi
          ;;
      esac
    done
  fi

  if [ -z "$CREATE_CONFIGSET" ]; then
    CREATE_CONFIGSET=data_driven_schema_configs
  fi

  # validate the configset arg
  if [[ ! -d "$SOLR_TIP/server/solr/configsets/$CREATE_CONFIGSET" && ! -d "$CREATE_CONFIGSET" ]]; then
    echo -e "\nSpecified configset $CREATE_CONFIGSET not found!\n"
    exit 1
  fi

  if [ -z "$CREATE_NAME" ]; then
    echo "$CREATE_TYPE name is required!"
    print_usage "$SCRIPT_CMD"
    exit 1
  fi

  if [ -z "$CREATE_PORT" ]; then
    for ID in `ps auxww | grep java | grep start.jar | awk '{print $2}' | sort -r`
      do
        port=`jetty_port "$ID"`
        if [ "$port" != "" ]; then
          CREATE_PORT=$port
          break
        fi
    done
  fi

  if [ -z "$CREATE_PORT" ]; then
    echo "Failed to determine the port of a local Solr instance, cannot create $CREATE_TYPE $CREATE_NAME"
    exit 1
  fi

  if [ "$SCRIPT_CMD" == "create_collection" ]; then
    run_tool create_collection -name $CREATE_NAME -shards $CREATE_NUM_SHARDS -replicationFactor $CREATE_REPFACT \
      -config $CREATE_CONFIGSET -configsetsDir $SOLR_TIP/server/solr/configsets -solrUrl http://localhost:$CREATE_PORT/solr
    exit $?
  else
    run_tool create_core -name $CREATE_NAME -solrUrl http://localhost:$CREATE_PORT/solr \
      -config $CREATE_CONFIGSET -configsetsDir $SOLR_TIP/server/solr/configsets
    exit $?
  fi
fi


# verify the command given is supported
if [ "$SCRIPT_CMD" != "stop" ] && [ "$SCRIPT_CMD" != "start" ] && [ "$SCRIPT_CMD" != "restart" ] && [ "$SCRIPT_CMD" != "status" ]; then
  print_usage "" "$SCRIPT_CMD is not a valid command!"
  exit 1
fi

# Run in foreground (default is to run in the background)
FG="false"
noprompt=false

if [ $# -gt 0 ]; then
  while true; do  
    case $1 in
        -c|-cloud)
            SOLR_MODE="solrcloud"
            shift
        ;;
        -d|-dir)
            if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
              print_usage "$SCRIPT_CMD" "Server directory is required when using the $1 option!"
              exit 1
            fi

            if [[ "$2" == "." || "$2" == "./" || "$2" == ".." || "$2" == "../" ]]; then
              SOLR_SERVER_DIR=`pwd`/$2
            else
              # see if the arg value is relative to the tip vs full path
              if [[ $2 != /* ]] && [[ -d "$SOLR_TIP/$2" ]]; then
                SOLR_SERVER_DIR="$SOLR_TIP/$2"
              else
                SOLR_SERVER_DIR="$2"
              fi
            fi
            # resolve it to an absolute path
            SOLR_SERVER_DIR=`cd "$SOLR_SERVER_DIR"; pwd`
            shift 2
        ;;
        -s|-solr.home)
            if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
              print_usage "$SCRIPT_CMD" "Solr home directory is required when using the $1 option!"
              exit 1
            fi

            SOLR_HOME="$2"
            shift 2
        ;;
        -e|-example)
            if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
              print_usage "$SCRIPT_CMD" "Example name is required when using the $1 option!"
              exit 1
            fi
            EXAMPLE="$2"
            shift 2
        ;;
        -f|-foreground)
            FG="true"
            shift
        ;;
        -h|-host)
            if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
              print_usage "$SCRIPT_CMD" "Hostname is required when using the $1 option!"
              exit 1
            fi
            SOLR_HOST="$2"
            shift 2
        ;;
        -m|-memory)
            if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
              print_usage "$SCRIPT_CMD" "Memory setting is required when using the $1 option!"
              exit 1
            fi
            SOLR_HEAP="$2"
            shift 2
        ;;
        -p|-port)
            if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
              print_usage "$SCRIPT_CMD" "Port number is required when using the $1 option!"
              exit 1
            fi
            SOLR_PORT="$2"
            shift 2
        ;;
        -z|-zkhost)
            if [[ -z "$2" || "${2:0:1}" == "-" ]]; then
              print_usage "$SCRIPT_CMD" "ZooKeeper connection string is required when using the $1 option!"
              exit 1
            fi
            ZK_HOST="$2"
            SOLR_MODE="solrcloud"
            shift 2
        ;;
        -a|-addlopts)
            ADDITIONAL_CMD_OPTS="$2"
            shift 2
        ;;
        -k|-key)
            STOP_KEY="$2"
            shift 2
        ;;
        -help|-usage)
            print_usage "$SCRIPT_CMD"
            exit 0
        ;;
        -noprompt)
            noprompt=true
            shift
        ;;
        -V|-verbose)
            verbose=true
            shift
        ;;
        -all)
            stop_all=true
            shift
        ;;
        --)
            shift
            break
        ;;
        *)
            if [ "${1:0:2}" == "-D" ]; then
              # pass thru any opts that begin with -D (java system props)
              SOLR_OPTS="$SOLR_OPTS $1"
              shift
            else
              if [ "$1" != "" ]; then
                print_usage "$SCRIPT_CMD" "$1 is not supported by this script"
                exit 1
              else
                break # out-of-args, stop looping
              fi
            fi
        ;;
    esac
  done
fi

if $verbose ; then
  echo "Using Solr root directory: $SOLR_TIP"
  echo "Using Java: $JAVA"
  $JAVA -version
fi

if [ "$SOLR_HOST" != "" ]; then
  SOLR_HOST_ARG="-Dhost=$SOLR_HOST"
else
  SOLR_HOST_ARG=""
fi

if [ -z "$SOLR_SERVER_DIR" ]; then
  SOLR_SERVER_DIR=$DEFAULT_SERVER_DIR
fi

if [ ! -e "$SOLR_SERVER_DIR" ]; then
  echo -e "\nSolr server directory $SOLR_SERVER_DIR not found!\n"
  exit 1
fi

CLOUD_NUM_NODES=2
declare -a CLOUD_PORTS=('8983' '7574' '8984' '7575');

# select solr.solr.home based on the desired example
if [ "$EXAMPLE" != "" ]; then
    case $EXAMPLE in
        cloud)
            #
            # Engage in an interactive session with user to setup the SolrCloud example
            #
            echo -e "\nWelcome to the SolrCloud example!\n\n"
            if $noprompt ; then
              CLOUD_NUM_NODES=2
              echo -e "Starting up $CLOUD_NUM_NODES Solr nodes for your example SolrCloud cluster."
            else
              echo -e "This interactive session will help you launch a SolrCloud cluster on your local workstation.\n"
              read -e -p "To begin, how many Solr nodes would you like to run in your local cluster? (specify 1-4 nodes) [2] " USER_INPUT
              while true
              do
                CLOUD_NUM_NODES=`echo $USER_INPUT | tr -d ' '`
                if [ -z "$CLOUD_NUM_NODES" ]; then
                  CLOUD_NUM_NODES=2
                fi
                if [[ $CLOUD_NUM_NODES > 4 || $CLOUD_NUM_NODES < 1 ]]; then
                  read -e -p "Please provide a node count between 1 and 4 [2] " USER_INPUT
                else
                  break;
                fi
              done
              
              echo -e "Ok, let's start up $CLOUD_NUM_NODES Solr nodes for your example SolrCloud cluster.\n"
              for (( s=0; s<$CLOUD_NUM_NODES; s++ ))
              do
                read -e -p "Please enter the port for node$[$s+1] [${CLOUD_PORTS[$s]}] " USER_INPUT
                while true
                do
                  # trim whitespace out of the user input
                  CLOUD_PORT=`echo $USER_INPUT | tr -d ' '`
                  
                  # handle the default selection or empty input
                  if [ -z "$CLOUD_PORT" ]; then
                    CLOUD_PORT=${CLOUD_PORTS[$s]}
                  fi
                                  
                  # check to see if something is already bound to that port
                  if [ "$hasLsof" != "" ]; then
                    PORT_IN_USE=`lsof -Pni:$CLOUD_PORT`
                    if [ "$PORT_IN_USE" != "" ]; then
                      read -e -p "Oops! Looks like port $CLOUD_PORT is already being used by another process. Please choose a different port. " USER_INPUT
                    else
                      CLOUD_PORTS[$s]=$CLOUD_PORT
                      echo $CLOUD_PORT
                      break;
                    fi
                  else
                    CLOUD_PORTS[$s]=$CLOUD_PORT
                    echo $CLOUD_PORT
                    break;
                  fi
                done
              done
            fi       

            # setup a unqiue solr.solr.home directory for each node
            CLOUD_EXAMPLE_DIR=$SOLR_TIP/example/cloud
            if [ ! -d "$CLOUD_EXAMPLE_DIR/node1/solr" ]; then
              echo "Creating Solr home directory $CLOUD_EXAMPLE_DIR/node1/solr"
              mkdir -p $CLOUD_EXAMPLE_DIR/node1/solr
              cp $DEFAULT_SERVER_DIR/solr/solr.xml $CLOUD_EXAMPLE_DIR/node1/solr/
              cp $DEFAULT_SERVER_DIR/solr/zoo.cfg $CLOUD_EXAMPLE_DIR/node1/solr/
            fi

            for (( s=1; s<$CLOUD_NUM_NODES; s++ ))
            do
              ndx=$[$s+1]
              if [ ! -d "$CLOUD_EXAMPLE_DIR/node$ndx" ]; then
                echo "Cloning Solr home directory $CLOUD_EXAMPLE_DIR/node1 into $CLOUD_EXAMPLE_DIR/node$ndx"
                cp -r $CLOUD_EXAMPLE_DIR/node1 $CLOUD_EXAMPLE_DIR/node$ndx
              fi
            done
            SOLR_MODE="solrcloud"
            SOLR_SERVER_DIR="$SOLR_TIP/server"
            SOLR_HOME="$CLOUD_EXAMPLE_DIR/node1/solr"
            SOLR_PORT=${CLOUD_PORTS[0]}
            shift
        ;;
        techproducts)
            SOLR_HOME="$SOLR_TIP/example/techproducts/solr"
            mkdir -p $SOLR_HOME
            if [ ! -f "$SOLR_HOME/solr.xml" ]; then
              cp $DEFAULT_SERVER_DIR/solr/solr.xml $SOLR_HOME/solr.xml
            fi
            EXAMPLE_CONFIGSET=sample_techproducts_configs
            shift
        ;;
        dih)
            SOLR_HOME="$SOLR_TIP/example/example-DIH/solr"
            shift
        ;;
        schemaless)
            SOLR_HOME="$SOLR_TIP/example/schemaless/solr"
            mkdir -p $SOLR_HOME
            if [ ! -f "$SOLR_HOME/solr.xml" ]; then
              cp $DEFAULT_SERVER_DIR/solr/solr.xml $SOLR_HOME/solr.xml
            fi
            EXAMPLE_CONFIGSET=data_driven_schema_configs
            shift
        ;;
        *)
            print_usage "start" "Unsupported example $EXAMPLE! Please choose one of: cloud, dih, schemaless, or techproducts"
            exit 1
        ;;
    esac
fi

if [[ "$FG" == "true" && "$EXAMPLE" != "" ]]; then
  FG="false"
  echo -e "\nWARNING: Foreground mode (-f) not supported when running examples.\n"
fi

if [ -z "$STOP_KEY" ]; then
  STOP_KEY="solrrocks"
fi

# stop all if no port specified
if [[ "$SCRIPT_CMD" == "stop" && -z "$SOLR_PORT" ]]; then
  if $stop_all; then
    none_stopped=true
    for PIDF in `find $SOLR_PID_DIR -name "solr-*.pid" -type f`
      do
        NEXT_PID=`cat $PIDF`
        port=`jetty_port "$NEXT_PID"`
        if [ "$port" != "" ]; then
          stop_solr "$SOLR_SERVER_DIR" "$port" "$STOP_KEY" "$NEXT_PID"
          none_stopped=false
        fi
        rm -f $PIDF
    done
    if $none_stopped; then
      echo -e "\nNo Solr nodes found to stop.\n"
    fi
  else
    # not stopping all and don't have a port, but if we can find the pid file for the default port 8983, then use that
    none_stopped=true
    if [ -e "$SOLR_PID_DIR/solr-8983.pid" ]; then
      PID=`cat $SOLR_PID_DIR/solr-8983.pid`
      CHECK_PID=`ps auxww | awk '{print $2}' | grep $PID | sort -r | tr -d ' '`
      if [ "$CHECK_PID" != "" ]; then
        port=`jetty_port "$CHECK_PID"`
        if [ "$port" != "" ]; then
          stop_solr "$SOLR_SERVER_DIR" "$port" "$STOP_KEY" "$CHECK_PID"
          none_stopped=false
        fi
        rm -f $SOLR_PID_DIR/solr-8983.pid
      fi
    fi
    if $none_stopped; then
      echo -e "\nMust either specify a port using -p or -all to stop all Solr nodes on this host.\nUse the status command to see if any Solr nodes are running."
      exit 1
    fi
  fi
  exit
fi

if [ -z "$SOLR_PORT" ]; then
  SOLR_PORT="8983"
fi

if [ -z "$STOP_PORT" ]; then
  STOP_PORT=`expr $SOLR_PORT - 1000`
fi

if [[ "$SCRIPT_CMD" == "start" ]]; then
  # see if Solr is already running
  SOLR_PID=`solr_pid_by_port "$SOLR_PORT"`

  if [ -z "$SOLR_PID" ]; then
    # not found using the pid file ... but use ps to ensure not found
    SOLR_PID=`ps auxww | grep start.jar | grep $SOLR_PORT | grep -v grep | awk '{print $2}' | sort -r`
  fi

  if [ "$SOLR_PID" != "" ]; then
    echo -e "\nPort $SOLR_PORT is already being used by another process (pid: $SOLR_PID)\nPlease choose a different port using the -p option.\n"
    exit 1
  fi
else
  # either stop or restart
  # see if Solr is already running
  SOLR_PID=`solr_pid_by_port "$SOLR_PORT"`
  if [ -z "$SOLR_PID" ]; then
    # not found using the pid file ... but use ps to ensure not found
    SOLR_PID=`ps auxww | grep start.jar | grep $SOLR_PORT | grep -v grep | awk '{print $2}' | sort -r`
  fi
  if [ "$SOLR_PID" != "" ]; then
    stop_solr "$SOLR_SERVER_DIR" "$SOLR_PORT" "$STOP_KEY" "$SOLR_PID"
  else
    if [ "$SCRIPT_CMD" == "stop" ]; then
      echo -e "No process found for Solr node running on port $SOLR_PORT"
      exit 1
    fi
  fi
fi

if [ -z "$SOLR_HOME" ]; then
  SOLR_HOME="$SOLR_SERVER_DIR/solr"
else
  if [[ $SOLR_HOME != /* ]] && [[ -d "$SOLR_SERVER_DIR/$SOLR_HOME" ]]; then
    SOLR_HOME="$SOLR_SERVER_DIR/$SOLR_HOME"
    SOLR_PID_DIR=$SOLR_HOME
  elif [[ $SOLR_HOME != /* ]] && [[ -d "`pwd`/$SOLR_HOME" ]]; then
    SOLR_HOME="`pwd`/$SOLR_HOME"
  fi
fi

# This is quite hacky, but examples rely on a different log4j.properties
# so that we can write logs for examples to $SOLR_HOME/../logs
if [ -z "$SOLR_LOGS_DIR" ]; then
  SOLR_LOGS_DIR=$SOLR_SERVER_DIR/logs
fi
EXAMPLE_DIR=$SOLR_TIP/example
if [ "${SOLR_HOME:0:${#EXAMPLE_DIR}}" = $EXAMPLE_DIR ]; then
  LOG4J_PROPS=$EXAMPLE_DIR/resources/log4j.properties
  SOLR_LOGS_DIR=$SOLR_HOME/../logs
fi

if [ -n "$LOG4J_PROPS" ]; then
  LOG4J_CONFIG="-Dlog4j.configuration=file:$LOG4J_PROPS"
fi

if [ "$SCRIPT_CMD" == "stop" ]; then
  # already stopped, script is done.
  exit 0
fi

# NOTE: If the script gets to here, then it is starting up a Solr node.

if [ ! -e "$SOLR_HOME" ]; then
  echo -e "\nSolr home directory $SOLR_HOME not found!\n"
  exit 1
fi
if [ ! -e "$SOLR_HOME/solr.xml" ]; then
  echo -e "\nSolr home directory $SOLR_HOME must contain a solr.xml file!\n"
  exit 1
fi

# backup the log files before starting
if [ -f $SOLR_LOGS_DIR/solr.log ]; then
  if $verbose ; then
    echo "Backing up $SOLR_LOGS_DIR/solr.log"
  fi
  mv $SOLR_LOGS_DIR/solr.log $SOLR_LOGS_DIR/solr_log_`date +"%Y%m%d_%H%M"`
fi

if [ -f $SOLR_LOGS_DIR/solr_gc.log ]; then
  if $verbose ; then
    echo "Backing up $SOLR_LOGS_DIR/solr_gc.log"
  fi
  mv $SOLR_LOGS_DIR/solr_gc.log $SOLR_LOGS_DIR/solr_gc_log_`date +"%Y%m%d_%H%M"`
fi

# if verbose gc logging enabled, setup the location of the log file
if [ "$GC_LOG_OPTS" != "" ]; then
  GC_LOG_OPTS="$GC_LOG_OPTS -Xloggc:$SOLR_LOGS_DIR/solr_gc.log"
fi

if [ "$SOLR_MODE" == "solrcloud" ]; then
  if [ -z "$ZK_CLIENT_TIMEOUT" ]; then
    ZK_CLIENT_TIMEOUT="15000"
  fi
  
  CLOUD_MODE_OPTS="-DzkClientTimeout=$ZK_CLIENT_TIMEOUT"
  
  if [ "$ZK_HOST" != "" ]; then
    CLOUD_MODE_OPTS="$CLOUD_MODE_OPTS -DzkHost=$ZK_HOST"
  else
    if $verbose ; then
      echo "Configuring SolrCloud to launch an embedded ZooKeeper using -DzkRun"
    fi

    CLOUD_MODE_OPTS="$CLOUD_MODE_OPTS -DzkRun"
  fi

  # and if collection1 needs to be bootstrapped
  if [ -e "$SOLR_HOME/collection1/core.properties" ]; then
    CLOUD_MODE_OPTS="$CLOUD_MODE_OPTS -Dbootstrap_confdir=./solr/collection1/conf -Dcollection.configName=myconf -DnumShards=1"
  fi
    
fi

# These are useful for attaching remove profilers like VisualVM/JConsole
if [ "$ENABLE_REMOTE_JMX_OPTS" == "true" ]; then

  if [ -z "$RMI_PORT" ]; then
    RMI_PORT=1$SOLR_PORT
  fi

  REMOTE_JMX_OPTS="-Dcom.sun.management.jmxremote \
-Dcom.sun.management.jmxremote.local.only=false \
-Dcom.sun.management.jmxremote.ssl=false \
-Dcom.sun.management.jmxremote.authenticate=false \
-Dcom.sun.management.jmxremote.port=$RMI_PORT \
-Dcom.sun.management.jmxremote.rmi.port=$RMI_PORT"

  # if the host is set, then set that as the rmi server hostname
  if [ "$SOLR_HOST" != "" ]; then
    REMOTE_JMX_OPTS="$REMOTE_JMX_OPTS -Djava.rmi.server.hostname=$SOLR_HOST"
  fi
else
  REMOTE_JMX_OPTS=""
fi

if [ "$SOLR_HEAP" != "" ]; then
  SOLR_JAVA_MEM="-Xms$SOLR_HEAP -Xmx$SOLR_HEAP"
fi

if [ -z "$SOLR_JAVA_MEM" ]; then
  SOLR_JAVA_MEM="-Xms512m -Xmx512m"
fi

if [ -z "$SOLR_TIMEZONE" ]; then
  SOLR_TIMEZONE="UTC"
fi

# Launches Solr in foreground/background depending on parameters
function launch_solr() {

  run_in_foreground="$1"
  stop_port="$STOP_PORT"
  
  SOLR_ADDL_ARGS="$2"

  # deal with Java version specific GC and other flags
  JAVA_VERSION=`echo "$($JAVA -version 2>&1)" | grep "java version" | awk '{ print substr($3, 2, length($3)-2); }'`
  if [ "${JAVA_VERSION:0:3}" == "1.7" ]; then
    # Specific Java version hacking
    GC_TUNE="$GC_TUNE -XX:CMSFullGCsBeforeCompaction=1 -XX:CMSTriggerPermRatio=80"
    JAVA_MINOR_VERSION=${JAVA_VERSION:(-2)}
    if [[ $JAVA_MINOR_VERSION -ge 40 && $JAVA_MINOR_VERSION -le 51 ]]; then
      GC_TUNE="$GC_TUNE -XX:-UseSuperWord"
      echo -e "\nWARNING: Java version $JAVA_VERSION has known bugs with Lucene and requires the -XX:-UseSuperWord flag. Please consider upgrading your JVM.\n"
    fi
  fi

  if $verbose ; then
    echo -e "\nStarting Solr using the following settings:"
    echo -e "    JAVA            = $JAVA"
    echo -e "    SOLR_SERVER_DIR = $SOLR_SERVER_DIR"
    echo -e "    SOLR_HOME       = $SOLR_HOME"
    echo -e "    SOLR_HOST       = $SOLR_HOST"
    echo -e "    SOLR_PORT       = $SOLR_PORT"
    echo -e "    STOP_PORT       = $STOP_PORT"
    echo -e "    SOLR_JAVA_MEM   = $SOLR_JAVA_MEM"
    echo -e "    GC_TUNE         = $GC_TUNE"
    echo -e "    GC_LOG_OPTS     = $GC_LOG_OPTS"
    echo -e "    SOLR_TIMEZONE   = $SOLR_TIMEZONE"

    if [ "$SOLR_MODE" == "solrcloud" ]; then
      echo -e "    CLOUD_MODE_OPTS = $CLOUD_MODE_OPTS"
    fi

    if [ "$SOLR_OPTS" != "" ]; then
      echo -e "    SOLR_OPTS        = $SOLR_OPTS"
    fi

    if [ "$SOLR_ADDL_ARGS" != "" ]; then
      echo -e "    SOLR_ADDL_ARGS   = $SOLR_ADDL_ARGS"
    fi

    if [ "$ENABLE_REMOTE_JMX_OPTS" == "true" ]; then
      echo -e "    RMI_PORT        = $RMI_PORT"
      echo -e "    REMOTE_JMX_OPTS = $REMOTE_JMX_OPTS"
    fi
    echo -e "\n"
  fi
    
  # need to launch solr from the server dir
  cd $SOLR_SERVER_DIR
  
  if [ ! -e "$SOLR_SERVER_DIR/start.jar" ]; then
    echo -e "\nERROR: start.jar file not found in $SOLR_SERVER_DIR!\nPlease check your -d parameter to set the correct Solr server directory.\n"
    exit 1
  fi

  SOLR_START_OPTS="-server -Xss256k $SOLR_JAVA_MEM $GC_TUNE $GC_LOG_OPTS $REMOTE_JMX_OPTS \
 $CLOUD_MODE_OPTS \
-DSTOP.PORT=$stop_port -DSTOP.KEY=$STOP_KEY \
$SOLR_HOST_ARG -Djetty.port=$SOLR_PORT \
-Dsolr.solr.home=$SOLR_HOME \
-Dsolr.install.dir=$SOLR_TIP \
-Duser.timezone=$SOLR_TIMEZONE \
-Djava.net.preferIPv4Stack=true $LOG4J_CONFIG \
$SOLR_OPTS"
  
  if [ "$SOLR_MODE" == "solrcloud" ]; then
    IN_CLOUD_MODE=" in SolrCloud mode"
  fi

  mkdir -p $SOLR_LOGS_DIR

  if [ "$run_in_foreground" == "true" ]; then
    echo -e "\nStarting Solr$IN_CLOUD_MODE on port $SOLR_PORT from $SOLR_SERVER_DIR\n"
    $JAVA $SOLR_START_OPTS $SOLR_ADDL_ARGS -jar start.jar
  else
    # run Solr in the background
    nohup $JAVA $SOLR_START_OPTS $SOLR_ADDL_ARGS -XX:OnOutOfMemoryError="$SOLR_TIP/bin/oom_solr.sh $SOLR_PORT $SOLR_LOGS_DIR" -jar start.jar 1>$SOLR_LOGS_DIR/solr-$SOLR_PORT-console.log 2>&1 & echo $! > $SOLR_PID_DIR/solr-$SOLR_PORT.pid
  
    # no lsof on cygwin though
    if [ "$hasLsof" != "" ]; then
      echo -n "Waiting to see Solr listening on port $SOLR_PORT"
      # Launch in a subshell to show the spinner
      (loops=0
      while true
      do
        running=`lsof -Pni:$SOLR_PORT`
        if [ -z "$running" ]; then
          if [ $loops -lt 6 ]; then
            sleep 5
            loops=$[$loops+1]
          else
            echo -e "Still not seeing Solr listening on $SOLR_PORT after 30 seconds!"
            tail -30 $SOLR_LOGS_DIR/solr.log
            exit;
          fi
        else
          SOLR_PID=`ps auxww | grep start.jar | grep $SOLR_PORT | grep -v grep | awk '{print $2}' | sort -r`
          echo -e "\nStarted Solr server on port $SOLR_PORT (pid=$SOLR_PID). Happy searching!\n"
          exit;
        fi
      done) &
      spinner $!
    else
      SOLR_PID=`ps auxww | grep start.jar | grep $SOLR_PORT | grep -v grep | awk '{print $2}' | sort -r`
      echo -e "\nStarted Solr server on port $SOLR_PORT (pid=$SOLR_PID). Happy searching!\n"
      exit;
    fi
  fi
}

if [ "$EXAMPLE" != "cloud" ]; then
  launch_solr "$FG" "$ADDITIONAL_CMD_OPTS"

  # create the core/collection for the requested example after launching Solr
  if [[ "$EXAMPLE" == "schemaless" || "$EXAMPLE" == "techproducts" ]]; then
    if [ "$SOLR_MODE" == "solrcloud" ]; then
      run_tool create_collection -name $EXAMPLE -shards 1 -replicationFactor 1 \
        -config $EXAMPLE_CONFIGSET -configsetsDir $SOLR_TIP/server/solr/configsets -solrUrl http://localhost:$SOLR_PORT/solr
      if [ $? -ne 0 ]; then
        exit 1
      fi
    else
      run_tool create_core -name $EXAMPLE -solrUrl http://localhost:$SOLR_PORT/solr \
        -config $EXAMPLE_CONFIGSET -configsetsDir $SOLR_TIP/server/solr/configsets
      if [ $? -ne 0 ]; then
        exit 1
      fi
    fi

    if [ "$EXAMPLE" == "techproducts" ]; then
      echo "Indexing tech product example docs from $SOLR_TIP/example/exampledocs"
      "$JAVA" -Durl=http://localhost:$SOLR_PORT/solr/$EXAMPLE/update -jar $SOLR_TIP/example/exampledocs/post.jar $SOLR_TIP/example/exampledocs/*.xml
    fi

    echo -e "\nSolr $EXAMPLE example launched successfully. Direct your Web browser to http://localhost:$SOLR_PORT/solr to visit the Solr Admin UI\n"
  fi
else
  #
  # SolrCloud example is a bit involved so needs special handling here
  #
  SOLR_SERVER_DIR=$SOLR_TIP/server
  SOLR_HOME=$SOLR_TIP/example/cloud/node1/solr
  SOLR_PORT=${CLOUD_PORTS[0]}

  if [ "$ZK_HOST" != "" ]; then
    DASHZ="-z $ZK_HOST"
  fi

  if [ "$SOLR_HEAP" != "" ]; then
    DASHM="-m $SOLR_HEAP"
  fi

  if [ "$ADDITIONAL_CMD_OPTS" != "" ]; then
    DASHA="-a $ADDITIONAL_CMD_OPTS"
  fi

  echo -e "\nStarting up SolrCloud node1 on port ${CLOUD_PORTS[0]} using command:\n"
  echo -e "solr start -cloud -s $SOLR_HOME -p $SOLR_PORT $DASHZ $DASHM $DASHA\n\n"
    
  # can't launch this node in the foreground else we can't run anymore commands
  launch_solr "false" "$ADDITIONAL_CMD_OPTS"

  # if user did not define a specific -z parameter, assume embedded in first cloud node we launched above
  zk_host=$ZK_HOST
  if [ -z "$zk_host" ]; then
    zk_port=$[$SOLR_PORT+1000]
    zk_host=localhost:$zk_port
  fi

  for (( s=1; s<$CLOUD_NUM_NODES; s++ ))
  do
    ndx=$[$s+1]
    next_port=${CLOUD_PORTS[$s]}
    echo -e "\n\nStarting node$ndx on port $next_port using command:\n"
    echo -e "solr start -cloud -s $SOLR_TIP/example/cloud/node$ndx/solr -p $next_port -z $zk_host $DASHM $DASHA \n\n"
    # call this script again with correct args for next node    
    $SOLR_TIP/bin/solr start -cloud -s $SOLR_TIP/example/cloud/node$ndx/solr -p $next_port -z $zk_host $DASHM $DASHA
  done
  
  # TODO: better (shorter) name??
  CLOUD_COLLECTION=gettingstarted
    
  if $noprompt ; then
    CLOUD_NUM_SHARDS=2
    CLOUD_REPFACT=2
    CLOUD_CONFIG=data_driven_schema_configs
  else
    echo -e "\nNow let's create a new collection for indexing documents in your $CLOUD_NUM_NODES-node cluster.\n"
    read -e -p "Please provide a name for your new collection: [gettingstarted] " USER_INPUT
    # trim whitespace out of the user input
    CLOUD_COLLECTION=`echo $USER_INPUT | tr -d ' '`

    # handle the default selection or empty input
    if [ -z "$CLOUD_COLLECTION" ]; then
      CLOUD_COLLECTION=gettingstarted
    fi                    
    echo $CLOUD_COLLECTION

    USER_INPUT=
    read -e -p "How many shards would you like to split $CLOUD_COLLECTION into? [2] " USER_INPUT
    # trim whitespace out of the user input
    CLOUD_NUM_SHARDS=`echo $USER_INPUT | tr -d ' '`
    
    # handle the default selection or empty input
    if [ -z "$CLOUD_NUM_SHARDS" ]; then
      CLOUD_NUM_SHARDS=2
    fi                    
    echo $CLOUD_NUM_SHARDS
    
    USER_INPUT=
    read -e -p "How many replicas per shard would you like to create? [2] " USER_INPUT
    # trim whitespace out of the user input
    CLOUD_REPFACT=`echo $USER_INPUT | tr -d ' '`
    
    # handle the default selection or empty input
    if [ -z "$CLOUD_REPFACT" ]; then
      CLOUD_REPFACT=2
    fi                    
    echo $CLOUD_REPFACT

    USER_INPUT=
    echo "Please choose a configuration for the $CLOUD_COLLECTION collection, available options are:"
    read -e -p "basic_configs, data_driven_schema_configs, or sample_techproducts_configs [data_driven_schema_configs] " USER_INPUT
    while true
    do
      # trim whitespace out of the user input
      CLOUD_CONFIG=`echo $USER_INPUT | tr -d ' '`

      # handle the default selection or empty input
      if [ -z "$CLOUD_CONFIG" ]; then
        CLOUD_CONFIG=data_driven_schema_configs
      fi

      # validate the configset arg
      if [[ ! -d "$SOLR_TIP/server/solr/configsets/$CLOUD_CONFIG" && ! -d "$CLOUD_CONFIG" ]]; then
        echo -e "\nOops! Specified configuration $CLOUD_CONFIG not found!"
        read -e -p "Choose one of: basic_configs, data_driven_schema_configs, or sample_techproducts_configs [data_driven_schema_configs] " USER_INPUT
        CLOUD_CONFIG=
      else
        break;
      fi
    done

  fi
   
  run_tool create_collection -name $CLOUD_COLLECTION -shards $CLOUD_NUM_SHARDS -replicationFactor $CLOUD_REPFACT \
    -config $CLOUD_CONFIG -configsetsDir $SOLR_TIP/server/solr/configsets -solrUrl http://localhost:$SOLR_PORT/solr
  echo -e "\n\nSolrCloud example running, please visit http://localhost:$SOLR_PORT/solr \n\n"
fi

exit $?
