/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.apache.lucene.gradle.checks.CheckWorkingCopy
import org.apache.lucene.gradle.checks.ForbiddenApisPluginWrapper
import org.apache.lucene.gradle.checks.RatSources
import org.apache.lucene.gradle.checks.CheckSourcePatterns
import org.apache.lucene.gradle.deps.MissingDeps
import org.apache.lucene.gradle.deps.UnusedDeps
import org.apache.lucene.gradle.deps.ListDeps
import org.apache.lucene.gradle.deps.JdepsReport
import org.apache.lucene.gradle.TopHints
import org.apache.lucene.gradle.PristineClean
import org.apache.lucene.gradle.SetDefaultUserConfig
import org.gradle.api.Project
import org.apache.commons.io.FilenameUtils
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin
import org.apache.lucene.gradle.DepInsightReportTask

plugins {
  id "com.palantir.consistent-versions" version "1.12.4"
}

// TOC
// -> Definitions
// -> Root project config
// -> All projects config
// -> Subprojects config
// -> Other config


// ### -> defs and all project ext config

buildDir = file("build")

File userHomeConfigFile = new File(System.getProperty("user.home") + '/user.properties')
if (userHomeConfigFile.exists()) {
  println 'Found user home user.gradle, loading ...'
  Properties props = new Properties()
  userHomeConfigFile.withInputStream { props.load(it) }

  for (java.util.Map$Entry<Map<String,String>> entry : props.entrySet()) {
    ext.set(entry.getKey(), entry.getValue())
  }
} else {
  println 'not user home user.gradle ' + userHomeConfigFile
}


// we add some custom ext methods here, including mfile
apply from: file("${rootDir}/buildSrc/common/configure-ext.gradle")

// build help tasks
apply from: mfile(rootDir, 'buildSrc/common/build-help.gradle')

// setup repositories
apply from: mfile(rootDir, 'buildSrc/common/configure-repositories.gradle')


// ### -> lucene-solr root project config

// TODO: enable the modified files checking only for jenkins runs! sysprop?
tasks.create('checkWorkingCopy', CheckWorkingCopy, false)


task testTimes(type: TopHints) {
  group = 'Tests'
  description = "Show the slowest tests (averages)."
}

task pristineClean(type: PristineClean) {}

task defaultUserConfig(type: SetDefaultUserConfig) {
  group = 'Build Setup'
  description = "Sets recommended starting build property values in ~/.gradle/gradle.properties. Use --agressive for better build performance. WARNING! This WILL modify your gradle.properties file."
}

ext.testsResults = [] // test result summaries
gradle.buildFinished {
  def allResults = ext.testsResults

  if (!allResults.isEmpty()) {
    printResults allResults
  }
}

// ### -> All project config
configure(allprojects) {
//  File userProjectConfigFile = project.rootProject.file('user.gradle')
//  if (userProjectConfigFile.exists()) {
//    println 'Found user project user.gradle, applying ...'
//    project.apply from: userProjectConfigFile
//  } else {
//    
//  }
//  
//  File userHomeConfigFile = new File(System.getProperty("user.home") + '/user.gradle')
//  if (userHomeConfigFile.exists()) {
//    println 'Found user home user.gradle, applying ...'
//    project.apply from: userHomeConfigFile
//  } else {
//    println 'not user home user.gradle ' + userHomeConfigFile
//  }

  
  
  // we apply eclipse to all projects - we want our formatting if you edit build.gradle in a non java project
  // as well as the ability to configure other things for all projects
  apply plugin: 'eclipse'
  project.afterEvaluate{
    project.apply from: mfile(rootDir, 'buildSrc/ide/eclipse.gradle')
  }
}

// ### -> Subprojects config
configure(subprojects) {

  buildDir = rootProject.mfile('build/' + getTopLvlProject().name, project.name)

  // setup repositories
  apply from: mfile(rootDir, 'buildSrc/common/configure-repositories.gradle')

  apply plugin: 'idea'

  plugins.withType(JavaPlugin) {
    project.apply from: mfile(rootDir, 'buildSrc/ide/idea.gradle')
  }

  task ratSources(type: RatSources) {
    group = 'Verification'
    description = "Checks source files for proper license headers."
    excludes = [
      '**/TODO',
      '**/*.txt,',
      '**/*.iml'
    ]
    // TODO: even if we don't have a check task, we want to run RAT - on our root files for example
    if (project.hasProperty('check')) {
      check.dependsOn ratSources
    }
  }
  
  task checkSourcePatterns(type: CheckSourcePatterns) {
    group = 'Verification'
    description = "Checks source files for project violations."
    baseDir = projectDir
    check.dependsOn checkSourcePatterns
  }

  plugins.apply(ForbiddenApisPluginWrapper)

  task depInsight(type: DepInsightReportTask) {
    group = 'Help'
    description = "An alternate to dependencyInsight that works across projects so that you can run it from the root directory or aggregate projects eg lucene, solr, solr-contrib"
  }

  configurations {
    sourceJarOutput
  }
  
  
  File jdepsReportDir = mfile(project.buildDir, 'jdepsreport')

  task jdepsReport(type: JdepsReport) {
    target = jdepsReportDir
  }

  task listDependencies(type: ListDeps) {
    group = 'Help'
    description = "List sorted dependencies and counts for a module."
  }

  task unusedDependencies {
    group = 'Help'
    description = "Lists dependencies that may be unused for a module."
    task unusedDeps(type: UnusedDeps) {
      inputDirectory jdepsReportDir
    }
    unusedDeps.dependsOn jdepsReport
    dependsOn unusedDeps
  }

  project(':buildSrc').tasks.unusedDeps.enabled = false

  task missingDependencies {
    group = 'Help'
    description = "Lists classes from this module with missing runtime dependencies (we ignore scanning some root deps (ie hadoop) and some violations (ie annotations)."
    task missingDeps(type: MissingDeps) {
      inputDirectory jdepsReportDir
    }
    missingDeps.dependsOn jdepsReport
    dependsOn missingDeps
  }

  project(':buildSrc').tasks.missingDeps.enabled = false
  
  // configure maven
  project.getPlugins().withType(MavenPublishPlugin) {

    // you can add the following above the apply maven-publish plugin to allow overriding in subprojects: project.ext.set("publishOverride", true)
    if (!project.hasProperty('publishOverride') || !project.publishOverride) {
      publishing {
        publications {
          mavenJava(MavenPublication) {
            from components.java
            artifact(tasks.sourceJar)
            artifact(tasks.packageJavadoc)
          }
        }
      }
    }
  }

  // dependencies block that applies to all projects
  dependencies {
    configurations.all {
      resolutionStrategy {
        force 'org.codehaus.woodstox:stax2-api:3.1.4' // clustering has old simple-xml dep that requires < 4.X
      }

      // stax-api classes are in Java 11
      exclude group: 'javax.xml.stream', module: 'stax-api'
      exclude group: 'stax', module: 'stax-api'
      exclude group: 'stax', module: 'stax'

      // logging jars we don't want, we use slf4j
      exclude group: 'log4j', module: 'log4j'
      exclude group: 'commons-logging', module: 'commons-logging'

      // exclude annotation jars that come with guava
      exclude group: 'com.google.code.findbugs', module: 'jsr305'
      exclude group: 'org.checkerframework', module: 'checker-qual'
      exclude group: 'com.google.errorprone', module: 'error_prone_annotations'
      exclude group: 'com.google.j2objc', module: 'j2objc-annotations'
      exclude group: 'org.codehaus.mojo', module: 'animal-sniffer-annotations'

      exclude group: 'org.slf4j', module: 'slf4j-log4j12' // zk and perhaps others can bring in log4j12 binding

      exclude group: 'xml-apis', module: 'xml-apis' // somehow can be inconsistenly brought in by xerces:xercesImpl - exlude it
    }

    modules {
      module("commons-logging:commons-logging") { replacedBy("org.slf4j:jcl-over-slf4j") }
      module("log4j:log4j") { replacedBy("org.slf4j:log4j-over-slf4j") }
    }
  }



  plugins.withType(JavaPlugin) {
    
    sourceCompatibility = "11"
    targetCompatibility = "11"

    // Use UTF-8, don't rely on local platform encoding.
    compileJava.options.encoding = "UTF-8"
    compileTestJava.options.encoding = "UTF-8"

    // project.compileJava.options.compilerArgs << '-Xlint:deprecation' << '-Xlint:unchecked'
    // project.compileTestJava.options.compilerArgs << '-Xlint:deprecation' << '-Xlint:unchecked'

    // fail on basic compiler warnings
    compileJava.options.compilerArgs << "-Werror"
    compileTestJava.options.compilerArgs << "-Werror"


    sourceSets {
      main.java.srcDirs = ['src/java']
      main.resources.srcDirs = ['src/resources']
      test.java.srcDirs = ['src/test']
      test.resources.srcDirs = ['src/test-files']
    }

    project.apply from: mfile(rootDir, 'buildSrc/common/configure-test.gradle')
    
    task sourceJar(type: Jar) {
      classifier 'sources'
      from sourceSets.main.allJava
    }
    jar.dependsOn sourceJar

    javadoc {
      options.encoding = 'UTF-8'
    }

    task packageJavadoc(type: Jar) {
      classifier = 'javadoc'
      from javadoc
    }

    configurations {
      sourceJarOutput
    }
    artifacts {
      sourceJarOutput sourceJar
    }
  }


}


// TODO: prob wont go here
//  task checkMissingJavaDocs {
//    group = 'Verification'
//    description = "Checks for missing JavaDocs."
//
//    doLast {
//      project.exec {
//        workingDir project.projectDir.getAbsolutePath()
//        executable "${python_exe}"
//        args = [
//          '-B',
//          rootProjectDir.getAbsolutePath() + '/dev-tools/scripts/checkJavaDocs.py',
//          project.projectDir.getAbsolutePath(),
//          'class'
//        ]
//      }
//    }
//  }

// TODO: check.dependsOn checkMissingJavaDocs




// ### -> Other config


// TODO: prob does not go here

// Single JavaDocs for all modules

def noJavaDocModules = [
  "buildSrc",
  "dev-tools",
  "lucene",
  "solr",
  "solr-ref-guide",
  "lucene-analysis",
  "lucene-backward-codecs",
  "solr-contrib",
  "solr-example",
  "solr-example-DIH"
]
def javaDocProjects = subprojects.findAll { project -> !noJavaDocModules.contains(project.name)}

// project.afterEvaluate{
//   task javadocAll(type: Javadoc) {
//     group = 'Documentation'
//     description = "Generates single JavaDoc for all modules."
//     javaDocProjects.each { println it.name;println it.sourceSets;evaluationDependsOn(it.path) }
//     source javaDocProjects.collect { it.sourceSets.main.allJava }
//     classpath = files(javaDocProjects.collect { it.sourceSets.main.compileClasspath })
//     destinationDir = file("${buildDir}/docs")
//   }
// }
