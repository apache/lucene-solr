/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent
import groovy.time.TimeCategory
import org.apache.lucene.gradle.TestResultObj
import org.apache.tools.ant.Project

test {
  group = 'Tests'
  description = "Runs project tests."

  outputs.upToDateWhen { false }

  useJUnit()
  
  filter {
    includeTestsMatching "*.Test*"
    includeTestsMatching "*.*Test"
    // So we can run with --tests wildcards from higher level dirs.
    setFailOnNoMatchingTests(false)
  }

  testLogging {
    events TestLogEvent.FAILED
    exceptionFormat TestExceptionFormat.FULL
    showExceptions true
    showCauses true
    showStackTraces true
  }

  afterSuite { desc, result ->
    // Only summarize results for whole modules.
    if (desc.parent)  {
      return
    }

    if (result.testCount == 0 && result.successfulTestCount == 0 && result.failedTestCount == 0 && result.skippedTestCount == 0) {
      return
    }
  
    String summary = "results: ${result.resultType} " +
        "(" +
        "${result.testCount} tests, " +
        "${result.successfulTestCount} successes, " +
        "${result.failedTestCount} failures, " +
        "${result.skippedTestCount} skipped" +
        ") " +
        "in ${TimeCategory.minus(new Date(result.endTime), new Date(result.startTime))}" +
        "\n" +
        "Report file: ${project.tasks.test.reports.html.entryPoint}"

    TestResultObj testResult = new TestResultObj("${project.name}:${project.tasks.test.name}", summary, result.resultType == TestResult.ResultType.SUCCESS)

    // Add reports in `testsResults`, keep failed suites at the end
    if (result.resultType == TestResult.ResultType.SUCCESS) {
      rootProject.testsResults.add(0, testResult)
    } else {
      rootProject.testsResults += testResult
    }
  }

  minHeapSize = "256m"
  maxHeapSize = "512m"

  jvmArgs +=  "-XX:+UseG1GC"
  jvmArgs +=  "-XX:MaxGCPauseMillis=500"
  jvmArgs +=  "-XX:+UnlockExperimentalVMOptions"
  jvmArgs +=  "-XX:G1MaxNewSizePercent=30"
  jvmArgs +=  "-XX:G1NewSizePercent=5"
  jvmArgs +=  "-XX:G1HeapRegionSize=32M"
  jvmArgs +=  "-XX:InitiatingHeapOccupancyPercent=70"

  // this allows tests to read classes and resources form other projects with the security manager
  def commonDir = "${rootDir}/build"

  systemProperty 'common.dir', "${commonDir}"

  workingDir = buildDir
  def tmpDir = file("${workingDir}/tests")

  doFirst {
    tmpDir.mkdirs()
  }

  // TODO: there is only one Solr class that needs this (ExternalPaths). Seems odd
  // to point at user.dir.
  systemProperty 'tests.src.home', System.getenv('user.dir')

  systemProperty 'common.dir', "${commonDir}"
  systemProperty 'build.dir', project.buildDir
  systemProperty 'tempDir', tmpDir
  systemProperty 'java.io.tmpdir', tmpDir
  systemProperty 'java.awt.headless', 'true'
  systemProperty 'jetty.testMode', '1'
  systemProperty 'jetty.insecurerandom', '1'
  systemProperty 'jdk.map.althashing.threshold', '0'

  systemProperty 'tests.seed', randomSeed

  // Allow overriding these properties with -Pkey=value. A null value means property not set unless overridden.
  [
    'tests.multiplier': '1',
    'tests.codec': 'random',
    'tests.postingsformat': 'random',
    'tests.docvaluesformat': 'random',
    'tests.locale': 'random',
    'tests.timezone': 'random',
    'tests.directory': 'random',
    'tests.linedocsfile': 'europarl.lines.txt.gz',
    'tests.nightly': 'false',
    'tests.weekly': 'false',
    'tests.monster': 'false',
    'tests.slow': 'true',
    'tests.cleanthreads.sysprop': 'perMethod',
    'tests.verbose': 'false',
    'tests.filterstacks': 'true',
    'tests.asserts': 'true',
    'tests.iters': null,
    'tests.filter': null
  ].each { prop, defValue ->
    def value = project.hasProperty(prop) ? project.getProperty(prop) : defValue
    if (value != null) {
      systemProperty prop, value
    }
  }

  // Enable assertions depending on tests.asserts.
  enableAssertions Boolean.parseBoolean(systemProperties['tests.asserts'])

  // replaces default random source to the nonblocking variant
  systemProperty 'java.security.egd', 'file:/dev/./urandom'
  
  if (project.hasProperty('testsPolicy')) {
    systemProperty 'java.security.manager', 'org.apache.lucene.util.TestSecurityManager'
    systemProperty 'java.security.policy', "${testsPolicy}"
  }

  if (project.hasProperty('tests_jvms')) {
    def testsJvms = tests_jvms
    maxParallelForks = Integer.parseInt(testsJvms)
  } else {
    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
  }

  if (project.hasProperty('tests_failfast')) {
    if (Boolean.parseBoolean(tests_failfast)) {
      failFast = true
    }
  }
}

// Some test resources and files are stored along the test sources
// and are expected to exist next to classes during tests
task copyTestResources(type: Copy) {
  from('src/test') {
    exclude '**/*.java'
  }
  into sourceSets.test.java.outputDir
}
processTestResources.dependsOn copyTestResources
